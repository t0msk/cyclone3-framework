#!/usr/bin/perl
package CRON::module;
use open ':utf8', ':std';
use encoding 'utf8';
use utf8;
use strict;

=head1 NAME

510-video_format.check.cron

=cut

=head1 DESCRIPTION

Automatically checks video_format items, its directories and depend video_part_file items. Converts and generates video_part_file items how in video_format items are defined

Checks related thumbnail images in a501

Checks all missing video_part_files (only check database entries)

Checks all video_formats which are updated or created as new

Checks all video_part_files which parents are changed

=head1 DEPENDS

=over

=item *

L<App::510::_init|app/"510/_init.pm">

=item *

L<App::501::_init|app/"501/_init.pm">

=item *

Proc::ProcessTable

=back

=cut

use App::510::_init;
use App::501::_init;
use Proc::ProcessTable;


=head1 INPUTS

=over

=item *

B<time_max> - max seconds to process (default 60*5 seconds)

=back

=cut



sub execute
{
	my %env=@_;
	
	# Check
	if (!$tom::addons{'a510'} || ($TOM::DB{'main'}{'name'} ne $App::510::db_name))
	{main::_log("not enabled, or set for another domain service");return 1;}
	
	alarm(0);
	$env{'time_max'}=60*10 unless $env{'time_max'};
	my $encode_max=$env{'parallel'}; # max parallel processes
		$encode_max=4 unless $encode_max;
	$env{'sql_limit'}=$encode_max*4; # find max files to encode
	
	
	# check directory of formats
	
	
	# check list of formats and its directories
	
	
	# check how many encoders are running parrallel
	my $t = new Proc::ProcessTable;
	my $encode;
	foreach my $p (@{$t->table})
	{
		next unless $p->{'cmndline'}=~/(mencoder|ffmpeg)/;
		next if $p->{'cmndline'}=~/sh -c/;
		$encode++;
	}
	main::_log("mencoders running - $encode");
	
	if ($encode >= $encode_max)
	{
		main::_log("sorry, too many encoding processes already running",1);
		return 1;
	}
	
	my $time_start=time();
	
	# find missing formats
	my $sql=qq{
		SELECT
			*
		FROM
			`$App::510::db_name`.a510_video_format
		WHERE
			status IN ('Y','L') AND
			required LIKE 'Y' AND
			name NOT LIKE 'original'
		ORDER BY
			RAND()
	};
	my %sth0=TOM::Database::SQL::execute($sql,'quiet'=>1);
	while (my %db0_line=$sth0{'sth'}->fetchhash())
	{
		main::_log("check video_part_files in video_format ID='$db0_line{'ID'}' name='$db0_line{'name'}'");
		
		# find all videos without this format
		my $sql=qq{
			SELECT
				video_part.ID AS video_part_ID,
				video_part.ID_entity AS video_part_ID_entity,
				file.ID AS file_ID
			FROM
				`$App::510::db_name`.a510_video_part AS video_part
			LEFT JOIN `$App::510::db_name`.a510_video_part_file AS file ON
			(
				video_part.ID = file.ID_entity AND file.ID_format = $db0_line{'ID'}
			)
			LEFT JOIN `$App::510::db_name`.a510_video AS video ON
			(
				video.ID_entity = video_part.ID_entity
			)
			LEFT JOIN `$App::510::db_name`.a510_video_attrs AS video_attrs ON
			(
				video_attrs.ID_entity = video.ID_entity
			)
			LEFT JOIN `$App::510::db_name`.a510_video_format AS format ON
			(
				format.ID_entity = $db0_line{'ID'}
			)
			WHERE
				video_part.status IN ('Y','N','W') AND
				video_attrs.status IN ('Y','N','W') AND
				video_part.process_lock = 'N' AND
				(file.ID IS NULL OR (format.datetime_create > file.datetime_create))
			ORDER BY
				video_part.ID_entity DESC, video_part.ID ASC
			LIMIT
				$env{'sql_limit'}
		};
		my %sth1=TOM::Database::SQL::execute($sql,'quiet'=>1);
		while (my %db1_line=$sth1{'sth'}->fetchhash())
		{
			main::_log("video_part ID='$db1_line{'video_part_ID'}' with missing/old format '$db0_line{'name'}'");
			
			# check this file again if is not already processed by parallel process
			my $sql=qq{
				SELECT
					video_part.ID
				FROM
					`$App::510::db_name`.a510_video_part AS video_part
				LEFT JOIN `$App::510::db_name`.a510_video_part_file AS file ON
				(video_part.ID = file.ID_entity AND file.ID_format = $db0_line{'ID'})
				LEFT JOIN `$App::510::db_name`.a510_video_format AS format ON
				(format.ID_entity = $db0_line{'ID'})
				WHERE
					video_part.ID = $db1_line{'video_part_ID'} AND
					video_part.status IN ('Y','N','W') AND
					(file.ID IS NULL OR (format.datetime_create > file.datetime_create))
				LIMIT
					1
			};
			my %sth2=TOM::Database::SQL::execute($sql,'quiet'=>1);
			my %db2_line=$sth2{'sth'}->fetchhash();
			if (!$db2_line{'ID'}){main::_log("this video_part_file.ID='' is already processed");next;}
			
			# lock this file encoding
			my $lock=new TOM::lock( $App::510::db_name . "::a510:encode video_part.ID=$db1_line{'video_part_ID'} video_format.ID=$db0_line{'ID'}")
			|| do {main::_log("this video_part_file.ID='$db1_line{'video_part_ID'}' is already processing");next};
			
			App::510::functions::video_part_file_generate(
				'video_part.ID' => $db1_line{'video_part_ID'},
				'video_format.ID' => $db0_line{'ID'}
			);
			
		}
		
		# find parrent format
		my %format_parent=App::020::SQL::functions::tree::get_parent_ID(
			'ID' => $db0_line{'ID'},
			'db_h' => 'main',
			'db_name' => $App::510::db_name,
			'tb_name' => 'a510_video_format'
		);
		
		if ($format_parent{'ID'})
		{
			# find videos which parent has been changed
			
			my $sql=qq{
				SELECT
					video_part.ID AS video_part_ID,
					video_part.ID_entity AS video_part_ID_entity,
					file1.ID AS file1_ID,
					file2.ID AS file2_ID
				FROM
					`$App::510::db_name`.a510_video_part AS video_part
				LEFT JOIN `$App::510::db_name`.a510_video_part_file AS file1 ON
				(
					video_part.ID = file1.ID_entity AND
					file1.ID_format = $format_parent{'ID'}
				)
				LEFT JOIN `$App::510::db_name`.a510_video_part_file AS file2 ON
				(
					video_part.ID = file2.ID_entity AND
					file2.ID_format = $db0_line{'ID'}
				)
				WHERE
					video_part.status IN ('Y','N','W') AND
					file1.status='Y' AND
					file2.status='Y' AND
					file1.datetime_create > file2.datetime_create
				LIMIT
					$env{'sql_limit'}
			};
			my %sth1=TOM::Database::SQL::execute($sql,'quiet'=>1);
			while (my %db1_line=$sth1{'sth'}->fetchhash())
			{
				main::_log("parent of video_file ID='$db1_line{'file2_ID'}' has been changed");
				
				# lock this file encoding
				my $lock=new TOM::lock($App::510::db_name."::a510:encode video_part.ID=$db1_line{'video_part_ID'} video_format.ID=$db0_line{'ID'}") 
				|| do {
					$encode++;
					return 1 if $encode_max<=$encode;
					next
				}; # when this video is noew already encoding, skip to next video
				
				App::510::functions::video_part_file_generate(
					'video_part.ID' => $db1_line{'video_part_ID'},
					'video_format.ID' => $db0_line{'ID'}
				);
				
#				return 1;
				
			}
			
		}
		
	}
	
	return 1
}



=head1 AUTHORS

Comsultia, Ltd. (open@comsultia.com)

=cut

1;

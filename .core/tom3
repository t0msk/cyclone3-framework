#!/usr/bin/perl
=head1 NAME

"V slobodnom state
 obcan moze rozmyslat
 o com chce
 a hovorit o com rozmysla"
 filozof Baruch Spinoza

"Build a system that even an idiot can use and only idiots will want to use it."
 Linus Torvalds

=cut

BEGIN
{
	$TOM::engine='pub';
	if ($ARGV[0] eq "debug"){$main::debug=1;shift @ARGV;}
	$main::debug=1 if $ENV{'CYCLONE3DEBUG'};
	if (!$ENV{'CYCLONE3PATH'})
	{
		$ENV{'CYCLONE3PATH'}="/www/TOM" if -d "/www/TOM"; # obsolete
		$ENV{'CYCLONE3PATH'}="/Cyclone3" if -d "/Cyclone3";
		$ENV{'CYCLONE3PATH'}="/srv/Cyclone3" if -d "/srv/Cyclone3";
	}
	require $ENV{'CYCLONE3PATH'}."/.core/.libs/TOM.pm";
}

use open ':utf8', ':std';
use if $] < 5.018, 'encoding','utf8';
use utf8; # encode = fromutf8, decode=toutf8
use strict; # scrict code
use CGI::Fast qw(:standard);
use TOM::Logger;
use vars qw/
	$CGI
	%FORM
	$RPC
	$H
	$DOC
	$action
	$DOC_BODY
	%DOC_HEADER
	$TPL
	%COOKIES
	%COOKIES_all
	%COOKIES_save
	%COOKIES_all_save
	%USRM
	%env
	$IAdm
	$IAdm_log
	$ITst
	$ITst_log
	$DBH
	%DB
	$LNG_cp
	$time_modules
	$page_statuscode
	$result
	$page_save
	$url_regexp
	$USRM_flag
	$location
	$location_code
	$sitemap
	%a210
	%key
	$cache
	/;
our $sig_term=1;


######################################################################################
######################################################################################


my $t=track TOM::Debug("Engine '$TOM::engine' and domain init");

eval
{
	my $t=track TOM::Debug('TOM::Engine::pub');
	require TOM::Engine::pub;
	$t->close();
};
if ($@)
{
	my @ERR=("Error occured during engine and domain initialization");
	push @ERR,$@;
	# tento error sa nevykona jedine v pripade ak samotna kniznica TOM::Error je chybna
	new CGI::Fast();
	TOM::Error::engine(@ERR);
	exit(1);
}

$t->close();


######################################################################################
######################################################################################


my $t_domain=track TOM::Debug("Domain service init");
eval
{
	
	# import Content-Type library
	main::_log("use Content-Type library type='$pub::DOC'");
	eval "use TOM::Document::".$pub::DOC; die "can't load library TOM::Document::($pub::DOC)" if $@;
	
	# import default header
	main::_log("require default.header");
	do $tom::P."/_dsgn/default.header"
		|| do $tom::P."/_dsgn/default.dsgn";
	
	push @main::mfiles, $tom::P.'/_dsgn/default.header'
		if -e $tom::P.'/_dsgn/default.header';
	
	$main::DOC_BODY=$main::TEMPLATE if $main::TEMPLATE;
	%main::DOC_HEADER=%main::HEADER if %main::HEADER;
	
	#$DOC_BODY = $TEMPLATE unless $DOC_BODY;
	
	# FIXME:[fordinal] check $tom::LNG_available ci je este vobec potrebna
	$tom::DSGN="default"; # default design portal variable
	$tom::LNG_available=$tom::LNG;
	
	# PRIPRAVIM SI DEFAULT DOC
	# FIXME:[fordinal] Odstranit spetnu kompatibilitu %HTML_HEADER a $HTML_TEMP
	main::_log("generating template $pub::DOC from default.dsgn");
	#if (keys %DOC_HEADER == 0)
	$main::H_clone=new TOM::Document(%DOC_HEADER);
	$main::H_clone->prepare();
	$main::H_clone->i($DOC_BODY);
	main::_log("DOC_BODY = $DOC_BODY");
	
	#if ($TOM::CACHE){require Tomahawk::cache;}; # budem logovat v pripade ze ho mam nastavene
	if ($TOM::LAYERS){require Tomahawk::layers;}; # budem robit s layermi tak natiahnem kniznicu
#	if ($TOM::STAT){require Tomahawk::stat;}; # budem robit weblog a a110 len v pripade ak nat.kniznicu
	require Tomahawk::stat;
	
	TOM::Database::connect::multi(@TOM::DB_pub_connect)
		|| die "Error during connection request to database server\n";
	# TODO:[fordinal] odstranit spetnu kompatibilitu $main::DBH
	$main::DBH=$main::DB{main};
	
	
	# TAHAM NASTAVENIE CACHE ()
	&Tomahawk::GetCACHE_CONF if $TOM::CACHE;
	$main::cache = $TOM::CACHE;
	
	# nastavenie pola klucov pre kodovanie (len tie ktore sa este pouzivaju)
	foreach (keys %tom::code_keys){push @tom::type_code,$_ unless $tom::code_keys{$_}{notuse};}
	
	# nulovanie ITsd a IAdm klucov (zrusenie spetnej kompatibility)
	$TOM::IAdm_key='';
	$TOM::ITst_key='';
	
	# aktivizovanie mod_rewrite 0.136
	main::_log("loading rewrite.conf");
	if (open (KEY,"<".$tom::P."/rewrite.conf"))
	{
		my $data;
		while (my $line=<KEY>)
		{
			$data.=$line;
		}
		close(KEY);
		TOM::Net::URI::rewrite::get($data);close(KEY);$tom::rewrite=1;
		$url_regexp=qr'(.)\?\|\?(.*?)(["\'#])';
		$tom::rewrite_time=time;
	}
	else
	{
		$tom::rewrite=0;
		$url_regexp=qr'\?\|\?(.*?)(["\'#])';
	}
	
	main::_log("loading 301.conf");
	if (open (KEY,"<".$tom::P."/301.conf"))
	{
		my $data;
		while (my $line=<KEY>)
		{
			$data.=$line;
		}
		TOM::Net::URI::301::get($data);
		close(KEY);
		$tom::301_time=time;
	}
	
	main::_log("loading type.conf");
	TOM::TypeID::read_conf($tom::P.'/type.conf');
	
	$TOM::engine_ready=1;
};

if ($@)
{
	#
	# tento error budem zobrazovat ako webpage 30 sekund
	# a potom sa ukoncim a pockam na restart ( ci uz nieje chyba odstranena )
	#
	my @ERR=("Error occured during domain service initialization");
	push @ERR,$@;
	#push @ERR,$!;
	#my $req=FCGI::Request();
	#my $time_err=time;
#	while ($req->Accept() >= 0)
#	{
		#my $time_this=time;
		
		main::_log("request in domain initialization error",1);
		
		TOM::Error::engine(@ERR);
		
		#if ($time_err+30<$time_this){exit(0);}
#	}
#	$req->Finish();
	exit(0);
}

$t_domain->close;

######################################################################################
######################################################################################
######################################################################################
######################################################################################

main::_log("START FCGI PID:$$ domain:$tom::H",3,"pub.mng",1);
main::_event('debug','engine.start',{
	'time_start' => $TOM::time_start,
	'time_ready' => Time::HiRes::time(),
	'time_to_ready' => int((Time::HiRes::time()-$TOM::time_start)*1000)/1000,
});

my %url_cache;
while ($main::CGI=new CGI::Fast())
{
	$ENV{'QUERY_STRING'}=$ARGV[0] if $ENV{'TERM'};
#	print "$ENV{'QUERY_STRING'}\n";exit;
	alarm($TOM::fcgi_timeout); # zacnem pocitat X sekund kym nezbehne request
	local $sig_term=0; # ignorujem TERM pocas behu requestu, povoleny je len pocas cakania na dalsi request
	local $TOM::DEBUG_log_file=$TOM::DEBUG_log_file;
	local $cache=$TOM::CACHE;
	
	if ($main::ENV{'HTTP_REMOTE_ADDR_SOURCE'})
	{
		$main::ENV{'REMOTE_ADDR'}=$main::ENV{'HTTP_REMOTE_ADDR_SOURCE'};
	}
	elsif ($main::ENV{'HTTP_X_FORWARDED_FOR'}=~/([\d+\.]+)/)
	{
		$main::ENV{'REMOTE_ADDR_ORIGINAL'}=$main::ENV{'REMOTE_ADDR'};
		$main::ENV{'REMOTE_ADDR'}=$1;
	}
	
	$main::ENV{'REMOTE_ADDR_PREFIX'}=$main::ENV{'REMOTE_ADDR'};
		$main::ENV{'REMOTE_ADDR_PREFIX'}=~s|^(\d+\.\d+\.\d+)\.\d+$|$1|;
	
	if (
			$main::ENV{'HTTP_PRAGMA'} eq "no-cache" && 
			$tom::admin_ip_regexp &&
			$main::ENV{'REMOTE_ADDR'}=~/$tom::admin_ip_regexp/
	)
	{
		$main::cache=0;
		$TOM::DEBUG_log_file=90;
		main::_log("IP=$main::ENV{'REMOTE_ADDR'} requested no-cache",3,"debug");
	}
	
	$main::request_code=Utils::vars::genhash(8);
	TOM::Debug::clear_namespaces();
	my $t_request=track TOM::Debug("request [".($tom::count+1)."/$TOM::max_count] at $TOM::hostname",'timer'=>1);
	my $t_preeval=track TOM::Debug("preeval");
	
	if (!$tom::count)
	{
		#
		# pri uplne prvom requeste akceptujem tento process za zivotaschopny
		#
		my $t_ready=track TOM::Debug("request_first");
		main::_log("FCGI IS READY (first request) PID:$$ domain:$tom::H",3,"pub.mng",1);
		
		$t_ready->close();
	}
	
	main::_log('localize variables');
	undef $!;
	$tom::count++;
	local %env;
	local $IAdm;
	local $IAdm_log;
	local $ITst;
	local $ITst_log;
	local $action;
	local $location;
	local $location_code='302';
	local $page_save;
	local $USRM_flag;
	local $sitemap;
	local $TPL;
	local %a210;
	local %key;
	local @main::page_header;
	my $rewrite_301;
	my %FORM_reject;
	$result="ok";
	$page_statuscode="200";
	$pub::output_log=0;
#	$main::ENV{'Expires'}="Mon, 1 Jan 1990 23:00:00 GMT";
	$main::ENV{'Expires'}="0";
	$main::ENV{'Cache-Control'}="no-cache";
	$main::ENV{'ESI'}=0; # ESI disabled by default
#	$main::ENV{'Pragma'}="no-cache";
	
	# override tom::lng
	local $tom::lng=$tom::lng;
	local $tom::lang=$tom::lang; # long-form of lng
	if ($main::ENV{'lng'}){main::_log("override \$tom::lng by ENV to '$main::ENV{'lng'}' from '$tom::lng'");$tom::lng=$main::ENV{'lng'};undef $tom::lang}
	# override tom::H
	local $tom::H=$tom::H;
	$tom::H_orig=$tom::H;
	local $tom::H_www=$tom::H_www;
	$tom::H_www_orig=$tom::H_www; # save original $tom::H_www
#	foreach (sort keys %main::ENV){main::_log("$_=$main::ENV{$_}",3,"debug");}
	
	$main::ENV{'HTTPS'}="on" if $main::ENV{'HTTP_X_FORWARDED_PROTO'}=~/https/;
	if ($main::ENV{'HTTPS'} && $tom::H_www_https)
	{
		$tom::H_www = $tom::H_www_https;
	}
	elsif ($main::ENV{'HTTPS'})
	{
		$tom::H_www =~s|^http:|https:|;
	}
	# main::_log("tom::H_www=$tom::H_www",3,"debug");
	if ($main::ENV{'domain'})
	{
		main::_log("override \$tom::H by ENV to '$main::ENV{'domain'}' from '$tom::H'");
		$tom::H=$main::ENV{'domain'};
		$tom::H_www=~s|^(http[s]?://)(.*)$|$1$tom::H|;
		$tom::H_www=~s|^http://|https://| if $main::ENV{'HTTPS'};
	}
	# override tom::H_www
	if ($main::ENV{'HTTP_HOST'} && $tom::H_www_by_HTTP_HOST)
	{
#		$tom::H=$main::ENV{'HTTP_HOST'};
		$tom::H_www=~s|^(http[s]?://)(.*)$|$1$main::ENV{'HTTP_HOST'}$tom::rewrite_RewriteBase|;
		$tom::H_www=~s|^http://|https://| if $main::ENV{'HTTPS'};
		main::_log("override \$tom::H_www by HTTP_HOST '$main::ENV{'HTTP_HOST'}' to '$tom::H_www'");
	}
	# override tom::Hm
	local $tom::Hm=$tom::Hm;
	local $tom::Hm_www=$tom::Hm_www;
	if ($main::ENV{'domain_master'})
	{
		main::_log("override \$tom::Hm by ENV to '$main::ENV{'domain_master'}' from '$tom::Hm'");
		$tom::Hm=$main::ENV{'domain_master'};
		$tom::Hm_www=~s|^(http[s]?://)(.*)$|$1$tom::Hm|;
	}
	# override $tom::D_cookie
	local $tom::D_cookie=$tom::D_cookie;
	if ($main::ENV{'domain_cookie'}){main::_log("override \$tom::D_cookie by ENV to '$main::ENV{'domain_cookie'}' from '$tom::D_cookie'");$tom::D_cookie=$main::ENV{'domain_cookie'}}
	# override $tom::H_cookie
	local $tom::H_cookie=$tom::H_cookie;
	if ($main::ENV{'hostname_cookie'}){main::_log("override \$tom::H_cookie by ENV to '$main::ENV{'hostname_cookie'}' from '$tom::H_cookie'");$tom::H_cookie=$main::ENV{'hostname_cookie'}}
	
	# no original, all links are with the same priority
	$tom::H_www_orig=$tom::H_www
		if (!@tom::H_www_multi && !$tom::H_www_https_onlyifrequired);
	
	if (!$main::ENV{'HTTPS'} && $tom::H_www=~/^https/) # sorry, but this request is not from HTTPS
	{
		$tom::H_www=~s|^https|http|;
	}
	
	local $TOM::Document::content_security_policy=$TOM::Document::content_security_policy;
	local $TOM::Document::frame_options=$TOM::Document::frame_options;
	
#	main::_log('DOS control');
#	if (TOM::Net::HTTP::DOS::processENV(%main::ENV))
#	{
#		print "Content-Type: ".$TOM::Document::content_type."; charset=$main::LNG_cp_this\n\n";
#		next;
#	}
	
	
#	my ($bann_ID,$bann_msg)=App::1B0::IsBanned(
#		'IP' => $main::ENV{'REMOTE_ADDR'},
#		'-type' => "pub");
#	if ($bann_ID)
#	{
#		main::_log("IP $main::ENV{'REMOTE_ADDR'} is banned",1);
#		print "Status: 404 Not Found\n";
#		print "Content-Type: ".$TOM::Document::content_type."; charset=$main::LNG_cp_this\n\n";
#		main::_log("IP \"$main::ENV{'REMOTE_ADDR'}\" banned from $tom::H",0,"pub.warn",1);
#		$t_preeval->close();
#		$t_request->close();
#		next;
#	}
	
	my $tom_request=new TOM::request({
		'host' => $main::ENV{'HTTP_HOST'},
		'request' => $main::ENV{'REQUEST_URI'}
	});
	
#	if ($TOM::CACHE && $TOM::CACHE_memcached) # set info into memcached Cyclone3 processtable
#	{
#		$Ext::CacheMemcache::cache->set(
#			'namespace'=>"c3process",
#			'key' => $TOM::hostname.':'.$$,
#			'value' => {
#				'time' => time(),
#				'start' => $TOM::time_start,
#				'count' => $tom::count,
#				'request_code' => $main::request_code,
#				'http_host' => $main::ENV{'HTTP_HOST'},
#				'request_uri' => $main::ENV{'REQUEST_URI'},
#			}
#		);
#	}
	
	$t_preeval->close();
	eval
	{
		my $t_eval=track TOM::Debug("eval",'timer'=>1);
		my $t_preprocess=track TOM::Debug("preprocess",'timer'=>1);
		
#		main::_log("redirecting SIG{ALRM} to die");
		local $SIG{ALRM} = sub {die "Timed out during page sending! limit $TOM::ALRM sec.\n"};
		
		#main::_log("get current_time");
		$main::ENV{'time_current'}=$main::time_current=$tom::time_current=time();
		
		local (
			$tom::Tsec,
			$tom::Tmin,
			$tom::Thour,
			$tom::Tmday,
			$tom::Tmon,
			$tom::Tyear,
			$tom::Twday,
			$tom::Tyday,
			$tom::Tisdst) = localtime($tom::time_current);
#		main::_log("hour=$tom::Thour");
		# doladenie casu
		$tom::Tyear+=1900;$tom::Tmon++;
		# zaciatok dnesneho dna
		$main::time_day=$tom::time_current-($tom::Thour*3600)-($tom::Tmin*60)-$tom::Tsec;
		# formatujem cas
		local (
			$tom::Fsec,
			$tom::Fmin,
			$tom::Fhour,
			$tom::Fmday,
			$tom::Fmon,
			$tom::Fyear,
			$tom::Fwday,
			$tom::Fyday,
			$tom::Fisdst
			) = (
			sprintf ('%02d', $tom::Tsec),
			sprintf ('%02d', $tom::Tmin),
			sprintf ('%02d', $tom::Thour),
			sprintf ('%02d', $tom::Tmday),
			sprintf ('%02d', $tom::Tmon),
			$tom::Tyear,
			$tom::Twday,
			$tom::Tyday,
			$tom::Tisdst);
		$tom::Tmom=$tom::Tmon;
		$tom::Fmom=$tom::Fmon;
		$main::ENV{'datetime_current'}=$tom::datetime=$tom::Fyear.'-'.$tom::Fmon.'-'.$tom::Fmday.' '.$tom::Fhour.':'.$tom::Fmin.':'.$tom::Fsec;
		
		local $TOM::Document::content_type=$TOM::Document::content_type;
		
		
		main::_log("request from IP='$main::ENV{'REMOTE_ADDR'}' FORWARDED_FOR='$main::ENV{'HTTP_X_FORWARDED_FOR'}'");
		$main::ENV{'REMOTE_COUNTRY_CODE'}='';
		if ($main::ENV{'GEOIP_ADDR'} || $main::ENV{'GEOIP_COUNTRY_CODE'})
		{
#			main::_log("GEOIP_ADDR=$main::ENV{'GEOIP_ADDR'} GEOIP_COUNTRY_CODE=$main::ENV{'GEOIP_COUNTRY_CODE'}",3,"geoip");
		}
		elsif ($TOM::Int::lng::GEOIP)
		{
			$main::ENV{'REMOTE_COUNTRY_CODE'} = $TOM::Int::lng::gi->country_code_by_addr($main::ENV{'REMOTE_ADDR'});
#			main::_log("\$TOM::Int::lng::GEOIP IP='$main::ENV{'REMOTE_ADDR'}' country_code='$main::ENV{'REMOTE_COUNTRY_CODE'}'",3,"geoip");
		}
		
		if ($main::ENV{'REQUEST_URI'}=~s/^\/core.pl/\//)
		{
			main::_log("standard CGI");
			$tom::rewrite_301=0;
			#alarm 0;
		}
		
		if ($main::ENV{'REQUEST_URI'}=~/^(\/favicon\.ico|\/robots\.txt|\/sitemap\.xml)$/)
		{
			$main::page_statuscode="404";
			TOM::Warning::engine(
				"The page you have requested can't be displayed",
				"This request type is not allowed on this service"
			);
			$t_preprocess->close();
			$t_eval->close();
			$t_request->close();
#			if ($TOM::CACHE && $TOM::CACHE_memcached){$Ext::CacheMemcache::cache->set('namespace'=>"c3process",'key' => $TOM::hostname.':'.$$,'value' => {'time' => time(),'start' => $TOM::time_start,'count' => $tom::count});}
			next;
		}
		
		$main::ENV{'REQUEST_URI_'}=$main::ENV{'REQUEST_URI'};
			$main::ENV{'REQUEST_URI_'}=~s|\?.*$||;
		
		#my $t_agent=track TOM::Debug("HTTP_USER_AGENT '$main::ENV{'HTTP_USER_AGENT'}'");
		my $t_agent=track TOM::Debug("UserAgent");
			$main::ENV{'HTTP_USER_AGENT'}=$main::ENV{'SHELL'} if $main::ENV{'SHELL'};
			$main::ENV{'HTTP_USER_AGENT'}=$main::ENV{'TERM'} if $main::ENV{'TERM'};
#			$main::ENV{'HTTP_USER_AGENT'}=" " unless $main::ENV{'HTTP_USER_AGENT'};
			
			main::_log("HTTP_USER_AGENT='$main::ENV{'HTTP_USER_AGENT'}'");
			
			($main::UserAgent,$main::UserAgent_name)= TOM::Net::HTTP::UserAgent::analyze($main::ENV{'HTTP_USER_AGENT'},IP=>$main::ENV{'REMOTE_ADDR'});
			main::_log("detected UserAgent='$main::UserAgent' UserAgent_name='$main::UserAgent_name' UserAgent_type='".($TOM::Net::HTTP::UserAgent::table[$main::UserAgent]{'agent_type'})."'");
			
			($main::Media,$main::Media_name,$main::Media_type)= TOM::Net::HTTP::Media::analyze($main::ENV{'HTTP_USER_AGENT'});
			main::_log("detected Media='$main::Media' Media_name='$main::Media_name' Media_type='$main::Media_type'");
			
#			# logovanie pre UserAgentov, ktori maju specialne zapnute logovanie;
#			local $TOM::DEBUG_log_file=$TOM::DEBUG_log_file;
			
			if ($TOM::Net::HTTP::UserAgent::table[$main::UserAgent]{'log'})
			{
				$TOM::DEBUG_log_file=90;
				main::_log("changed to full logging");
			}
			
			main::_log("unknown UserAgent \"$main::ENV{'HTTP_USER_AGENT'}\" encodings($ENV{HTTP_ACCEPT_CHARSET})",0,"pub.warn",1) unless $main::UserAgent;
			main::_log("notfinished UserAgent \"$main::UserAgent_name\"-\"$main::ENV{'HTTP_USER_AGENT'}\" encodings($ENV{HTTP_ACCEPT_CHARSET}) (".$main::ENV{'REMOTE_ADDR'}.")",0,"pub.warn_low",1) if $TOM::Net::HTTP::UserAgent::table[$main::UserAgent]{notfinished};
			
			# USER_AGENT prisposobovanie
			if (($TOM::Net::HTTP::UserAgent::table[$main::UserAgent]{'engine_disable'})
				&&($pub::engine_disabling))
			{
				my @ERR=(
					"The page you have requested cannot be displayed, because of inappropriate activities",
					"Contact: info\@comsultia.com"
#					,@{$TOM::Net::HTTP::UserAgent::table[$main::UserAgent]{'messages'}}
				);
				main::_log("engine_disable for UserAgent \"$main::UserAgent_name\"-\"$main::ENV{'HTTP_USER_AGENT'}\"",0,"pub.warn",1);
				push @ERR, $TOM::Net::HTTP::UserAgent::messages{'old'}[$TOM::Net::HTTP::UserAgent::table[$main::UserAgent]{'old'}]
					if exists $TOM::Net::HTTP::UserAgent::table[$main::UserAgent]{'old'};
				# FIXME:[fordinal] zrusit Tomahawk::error::page_warn(@ERR) a nahradit novym
				
				$t_agent->close();
				$t_preprocess->close();
				$t_eval->close();
				$t_request->close();
				TOM::Warning::engine(@ERR);
#				if ($TOM::CACHE && $TOM::CACHE_memcached){$Ext::CacheMemcache::cache->set('namespace'=>"c3process",'key' => $TOM::hostname.':'.$$,'value' => {'time' => time(),'start' => $TOM::time_start,'count' => $tom::count});}
				
				TOM::Debug::pub::request(
					'duration' => $t_eval->{'time'}{'duration'},
					'user' => $t_eval->{'time'}{'user'}{'duration'},
					'sys' => $t_eval->{'time'}{'sys'}{'duration'},
					'code' => '429'
				);
				
				next;
			}
			
			if (my $dom=TOM::Net::HTTP::referer::analyze( (TOM::Net::HTTP::domain_clear($main::ENV{'HTTP_REFERER'}))[0] ))
			{
				$main::ENV{'REF_TYPE'}=$TOM::Net::HTTP::referer::table{$dom}{'ref_type'};
			}
			
		$t_agent->close();
		
		
		# prezriem si pravidla pre rewrite.conf
		if ($tom::rewrite && TOM::file_modified($tom::P.'/rewrite.conf'))
		{
			main::_log("rewrite.conf changed, reloading");
			if (open (KEY,"<".$tom::P."/rewrite.conf"))
			{
				my $data;
				while (my $line=<KEY>){$data.=$line;}
				close(KEY);
				TOM::Net::URI::rewrite::get($data);close(KEY);$tom::rewrite=1;#$/="\n";
				$tom::rewrite_time=$main::time_current;
			}
			
		}
		
		
		local @TOM::Net::URI::rewrite::rules=@TOM::Net::URI::rewrite::rules;
		
		if ($tom::rewrite)
		{
			my $rewrite_conf='*';
			# add a201_path_prefix when in secondary domain
			foreach (grep {defined $_->{'H'} && defined $_->{'rewrite.conf'}} @tom::H_www_multi)
			{
				if ($_->{'H'} eq $main::ENV{'HTTP_HOST'})
				{
					$rewrite_conf = $_->{'rewrite.conf'};
					main::_log('overriding $rewrite_conf from * to ' . $rewrite_conf);
					last;
				}
			}
			
			if (-e $tom::P.'/rewrite.'.($main::ENV{'HTTP_HOST'}).'.conf')
			{
				main::_log("[rewrite.".($main::ENV{'HTTP_HOST'})."].conf, loading");
				if (open (KEY,"<".$tom::P.'/rewrite.'.($main::ENV{'HTTP_HOST'}).'.conf'))
				{
					local $/;my $data=<KEY>;close(KEY);
					TOM::Net::URI::rewrite::get($data);$tom::rewrite=1;
				}
			}
			elsif (-e $tom::P.'/rewrite.'.($rewrite_conf).'.conf')
			{
				main::_log("[rewrite.".($rewrite_conf)."].conf, loading");
				if (open (KEY,"<".$tom::P.'/rewrite.'.($rewrite_conf).'.conf'))
				{
					local $/;my $data=<KEY>;close(KEY);
					TOM::Net::URI::rewrite::get($data);$tom::rewrite=1;
				}
			}
		}
		
		# prezriem si pravidla pre type.conf
		if (TOM::file_modified($tom::P.'/type.conf'))
		{
			main::_log("type.conf changed, reloading");
			TOM::TypeID::read_conf($tom::P.'/type.conf');
		}
		
		# prezriem si pravidla pre 301.conf
		if (TOM::file_modified($tom::P.'/301.conf'))
		{
			main::_log("301.conf changed, reloading");
			if (open (KEY,"<".$tom::P."/301.conf"))
			{
				my $data;
				while (my $line=<KEY>){$data.=$line;};
				close(KEY);
				TOM::Net::URI::301::get($data);close(KEY);
				$tom::301_time=$main::time_current;
			}
		}
		
		# osetrenie ...piiiiiip.... vyhladavacov ktore nepoznaju ?
		# a namiesto neho daju %3F, pricom je url_rewrite a hned je cela linka v REQUEST_URI
		# napr. tiscali search
		
		main::_log("input REQUEST_URI='$ENV{'REQUEST_URI'}'");
		main::_log("input QUERY_STRING='$ENV{'QUERY_STRING'}'");
		main::_log("input CONTENT_TYPE='$ENV{'CONTENT_TYPE'}' CONTENT_LENGTH='$ENV{'CONTENT_LENGTH'}'");
		
		my $t_querystring=track TOM::Debug("query");
		
		
		if (my $hacked=TOM::Net::HTTP::hacked::check($main::ENV{'REQUEST_URI'}))
		{
			main::_log("By REQUEST_URI='$main::ENV{'REQUEST_URI'}' this request is from virus or hacked computer (IP='$main::ENV{'REMOTE_ADDR'}') from $ENV{HTTP_REFERER}",1);
			main::_log("[$tom::H] By REQUEST_URI='$main::ENV{'REQUEST_URI'}' this request is from virus or hacked computer (IP='$main::ENV{'REMOTE_ADDR'}') from $ENV{HTTP_REFERER}",4,"$TOM::engine.hacked",1);
			TOM::Net::HTTP::hacked::add($main::ENV{'REMOTE_ADDR'});
			
			TOM::Warning::engine(
				"The page you have requested can't be displayed",
				"This request type is not allowed on this service"
			);
			
			$t_querystring->close();
			$t_preprocess->close();
			$t_eval->close();
			$t_request->close();
#			if ($TOM::CACHE && $TOM::CACHE_memcached){$Ext::CacheMemcache::cache->set('namespace'=>"c3process",'key' => $TOM::hostname.':'.$$,'value' => {'time' => time(),'start' => $TOM::time_start,'count' => $tom::count});}
			next;
		}
		
		# povodne 301.conf
		
		if (!$ENV{'QUERY_STRING'} && $ENV{'REQUEST_URI'}=~s/%3F/?/)
		{
			main::_log('%3F in REQUEST_URI, reparsing by it');
			($ENV{'REQUEST_URI'},$ENV{'QUERY_STRING'})=split('\?',$ENV{'REQUEST_URI'},2);
		}
		
		# odstranim ak sa tu este nachadza
		# (niektore vyhladavace ho tam nechavaju = je to znak '?')
#		main::_log('%3F cleaning');
		$ENV{'QUERY_STRING'}=~s/^%3F//;
		
		# ak potrebujem hackovat
		# toto tu musi ostat, bohuzial :(((
#		if ($TOM::type_code && $ENV{'QUERY_STRING'}=~s|=1(.*)||)
#		{
#			$ENV{'QUERY_STRING_PLUS'}=$1;
#			main::_deprecated("hacked with string QUERY_STRING_PLUS='$ENV{'QUERY_STRING_PLUS'}'");
#		}
		
		if ($TOM::type_code && $ENV{'QUERY_STRING'}=~s|\?(.*)||)
		{
			$ENV{'QUERY_STRING_PLUS'}=$1;
			main::_log("lighthack with string QUERY_STRING_PLUS='$ENV{'QUERY_STRING_PLUS'}'");
		}
		
		$ENV{'QUERY_STRING_orig'}=$ENV{'QUERY_STRING'};
		
		# secure kodovanie url
#		$env{admin}="request" if $ENV{'QUERY_STRING'}=~s|^admin||;
#		$env{test}="request" if $ENV{'QUERY_STRING'}=~s|^test||; # ITst mode
		
		
		if ($TOM::type_code && $ENV{'QUERY_STRING'})
		{
			my $t_type_code=track TOM::Debug('decode QUERY_STRING');
			
			# oprava pipe na zaciatok pre ludi so zlym browserom
			$ENV{'QUERY_STRING'}=~s|^(%7C%7C\|%7c%7c\|__)|\|\||g;
			# FIXME: vyhodit spetnu kompatibilitu s %7C%7C a ||
			if ($ENV{'QUERY_STRING'}=~s/^\|\|//) #
			{
				main::_log("query is with two pipes (or '__')");
				if ($ENV{'QUERY_STRING'}=~/-/) #
				{
					main::_log("splitted by '-' to hash and key name");
					
					if ($ENV{'QUERY_STRING'}=~s/^(.*?)-v4$//) #
					{
						main::_log("query is encoded string '$1'");
						my $var=$1;
						$var=TOM::Net::URI::URL::url_decode($var);
						$ENV{'QUERY_STRING'}=MIME::Base64::decode_base64($var."==");
						main::_log("output QUERY_STRING='$ENV{'QUERY_STRING'}'");
					}
					elsif ($ENV{'QUERY_STRING'}=~s/^(.*)-(.*?)-v(\d)$//) #
					{
						main::_log("deprecated encoding v3");
						$ENV{'QUERY_STRING'}="";
						$main::page_statuscode=404;
					}
					else
					{
						$ENV{'QUERY_STRING_CUT'}=$ENV{'QUERY_STRING'};$ENV{'QUERY_STRING'}="";
					}
				}
				else
				{
					main::_log("md5 decoding by table TOM._url");
					my $db0=$main::DB{sys}->Query("SELECT url FROM TOM._url WHERE hash='$ENV{QUERY_STRING}' LIMIT 1");
					if (my @db0_line=$db0->fetchrow)
					{
						$ENV{'QUERY_STRING'}=$db0_line[0];
						utf8::decode($ENV{'QUERY_STRING'});
						main::_log("readed from database QUERY_STRING='$ENV{'QUERY_STRING'}'");
					}
					else
					{
						$ENV{'QUERY_STRING'}="";
					}
				}
			}
			else
			{
				# povodne som zakazoval posielanie beznych premennych, za kodovanou linkou teraz uz nezakazujem
				# takze je povolene pretazovat
				#$ENV{'QUERY_STRING'}="";
			}
			$t_type_code->close();
		}
		
		# predlzenie linky
		$ENV{'QUERY_STRING'}.=$ENV{'QUERY_STRING_PLUS'};
		
		# dekodovanie % znakov
		#$ENV{'QUERY_STRING'}=TOM::Net::URI::URL::url_decode($ENV{'QUERY_STRING'});
		
		
		# nemozem si len tak halabala decodovat cely REQUEST_URI, mozem tak dekodovat len 
		# domenu a rewritovany tvar linky. ostatne veci za ? musia ostat v takom tvare v akom som ich dostal.
		# dekoduju sa az po spracovani
		do
		{
			my ($uri_1,$uri_2)=split('\?',$ENV{'REQUEST_URI'},2);
			#$ENV{'REQUEST_URI'}=TOM::Net::URI::URL::url_decode($uri_1);
			$ENV{'REQUEST_URI'}=TOM::Net::URI::URL::url_decode($uri_1);
			$ENV{'REQUEST_URI'}.='?'.$uri_2 if $uri_2;
			# pokial volam v linke priamo core.tom, tak osetrim linku
			# aby sa z tohto prefixu pomocou rewrite nestalo napr. TypeID
			$ENV{'REQUEST_URI'}='' if $ENV{'REQUEST_URI'}=~/^\/core.tom/;
		};
		
		# request_uri decoding
		
		
		#
		#  Get %FORM data from GET, POST, REQUEST_URI
		#
		
		%FORM=();
		#%{$RPC}=();
		$RPC={};
		my %FORM_rewrite=();
		
		# parse rewrited part of url and translate it to variables by rewrite.conf
		if ($tom::rewrite)
		{
			main::_log("decode rewrited link REQUEST_URI='$ENV{'REQUEST_URI'}' and generating \%FORM_rewrite");
			%FORM_rewrite=TOM::Net::URI::rewrite::parse_URL($ENV{'REQUEST_URI'});
			foreach (keys %{$FORM_rewrite{'GET'}})
			{
				$FORM{$_}=$FORM_rewrite{'GET'}{$_};
			}
		}
		
		# when I'm running publisher from commandline replace QUERY_STRING by params
		#$ENV{'QUERY_STRING'}=$ARGV[0] if $ENV{USER} eq "apache";
		
		# add to %FORM sended data in POST and GET (in this order)
		my %FORM_get=TOM::Net::HTTP::CGI::get_CGI($ENV{'QUERY_STRING'});
		foreach (keys %FORM_get)
		{
			$FORM{$_}=$FORM_get{$_};
		}
		
		main::_log("processed QUERY_STRING='$main::ENV{'QUERY_STRING'}'");
		
		#
		# %FORM filled
		#
		
		# cache disable if requested
		if ($main::ENV{'HTTP_PRAGMA'} eq "no-cache")
		{
			main::_log("requested no-cache (don't know if proceed)");
		}
		
		# allow recache with _rc pram only in devel server
		if ($tom::devel && $main::FORM{'_rc'} < 0)
		{
			$main::cache=0;
			$TOM::DEBUG_log_file=90;
			main::_log("IP=$main::ENV{'REMOTE_ADDR'} requested no-cache",3,"debug");
		}
		
		# add a201_path_prefix when in sub-domain
		foreach (grep {defined $_->{'H'} && defined $_->{'a210_path_prefix'}} @tom::H_www_multi)
		{
			if ($tom::H_www=~/^https?:\/\/$_->{'H'}$/)
			{
				$main::FORM{'a210_path'}=
					$_->{'a210_path_prefix'}.'/'.$main::FORM{'a210_path'};
				$main::FORM{'a210_path'}=~s|/$||;
				last;
			}
		}
		
		$main::ENV{'QUERY_STRING_FULL'}=TOM::Net::URI::URL::genGET(%main::FORM);
		
		main::_log("QUERY_STRING_FULL='$main::ENV{'QUERY_STRING_FULL'}'");
		
		$t_querystring->close();
		
		# DEFINE REF_TYPE when not detected by HTTP_REFERER in TOM::Net::HTTP::referer
		if ($main::ENV{'HTTP_REFERER'} && !$main::ENV{'REF_TYPE'}){$main::ENV{'REF_TYPE'}="web";}
		$main::ENV{'REF_TYPE'}="cpc" if $FORM{'gclid'}; # adwords campaing hack
		$main::ENV{'REF_TYPE'}=$FORM{'utm_medium'} if $FORM{'utm_medium'}; # other campaings hack
		$main::ENV{'REF_TYPE'}=$FORM{'ref'} if $FORM{'ref'};
		$main::ENV{'REF_TYPE'}='onsite' if $main::ENV{'HTTP_REFERER'}=~/^http[s]?:\/\/[a-z\.]*?$tom::H/;
		$main::ENV{'REF_TYPE'}='onsite' if ($tom::Hm && ($main::ENV{'HTTP_REFERER'}=~/^http[s]?:\/\/[a-z\.]*?$tom::Hm/));
		$main::ENV{'REF_TYPE'}='direct' unless $main::ENV{'REF_TYPE'};
		# fixes
		$main::ENV{'REF_TYPE'}='feed' if $main::ENV{'REF_TYPE'} eq "rss";
		
#		main::_log("referer='$main::ENV{'HTTP_REFERER'}' ref_type='$main::ENV{'REF_TYPE'}'",3,"pub.ref",2);
		
		# only browser can recache content of a page
		# when another useragent type uses URL with _rc, then is redirected by code 301
		if (
				(not $TOM::Net::HTTP::UserAgent::table[$main::UserAgent]{agent_type}=~/browser/) && ($main::FORM{'_rc'})
			)
		{
			delete $main::FORM{'_rc'};
			$rewrite_301=1;
		};
		
		if (my $out=TOM::Net::URI::301::check($ENV{'REQUEST_URI'},\%main::FORM))
		{
			my $t_301=track TOM::Debug("301 redirect");
			
			if ($out=~/^-(\d+)/)
			{
				my $code=$1;
				main::_log("code $1 on REQUEST_URI='$ENV{'REQUEST_URI'}'",1);
				
				$t_301->close();
				$t_preprocess->close();
				$t_eval->close();
				$t_request->close();
				print "Status: $code Unknown\n";
				print "Content-Type: text/html; charset=UTF-8\n";
				print "\n";
				
				print "<HTML><HEAD></HEAD><BODY><H1>$code</H1></BODY></HTML>\n";
				
#				if ($TOM::CACHE && $TOM::CACHE_memcached){$Ext::CacheMemcache::cache->set('namespace'=>"c3process",'key' => $TOM::hostname.':'.$$,'value' => {'time' => time(),'start' => $TOM::time_start,'count' => $tom::count});}
				next;
			}
			
			
			main::_log("301 redirect to '$out'");
			
			if ($out=~/^http/)
			{
				# ide kod 301
#				main::_log("301 from $ENV{HTTP_HOST}$ENV{REQUEST_URI} to '$out' (301.conf)",3,"pub.301",1);
#				main::_log("301 from $ENV{HTTP_HOST}$ENV{REQUEST_URI} to '$out' (301.conf)",3,"pub.301");
#				main::_log("301 from $ENV{HTTP_HOST}$ENV{REQUEST_URI} to '$out' (301.conf)");
				
				$t_301->close();
				$t_preprocess->close();
				$t_eval->close();
				$t_request->close();
				TOM::Debug::pub::request(
					'duration' => $t_eval->{'time'}{'duration'},
					'user' => $t_eval->{'time'}{'user'}{'duration'},
					'sys' => $t_eval->{'time'}{'sys'}{'duration'},
					'code' => '301',
					'location' => $out
				);
				print "Status: 301 Moved permanently\n";
				print "C3-Request: $main::request_code\n";
				print "Location: $out\n\n";
				
#				if ($TOM::CACHE && $TOM::CACHE_memcached){$Ext::CacheMemcache::cache->set('namespace'=>"c3process",'key' => $TOM::hostname.':'.$$,'value' => {'time' => time(),'start' => $TOM::time_start,'count' => $tom::count});}
				next;
			}
			
			if ($out=~s/^\?\|\?//)
			{
				main::_log("encoding URL");
				
				my %form=TOM::Net::HTTP::CGI::GetQuery($out,'-lite'=>1);
				
				my ($rewrite_domain,$rewrite)=TOM::Net::URI::rewrite::parse_hash(\%form);
					$rewrite="/".$rewrite;
				main::_log("rewrited part is '$rewrite' domain '$rewrite_domain'");
				
				my $link;
				my $var='';
				if (keys %form > 0)
				{
					$var=TOM::Net::URI::URL::genGET(%form);
				}
				
				main::_log("rewrite_domain='$rewrite_domain' rewrite='$rewrite' URL='$var'");
				my $link;
				if
					(
						($TOM::type_code) # kodujem
						&&
						($var) # vo var vobec nieco je
					)
				{
					# defaultne lubovolny key
					my $key;
					# v pripade ze som robot tak ked pridem na stranku linkou hashovanou pomocou
					# kluca ktory nieje urceny pre robota, tak sa presmerujem na linku len s takymto
					# hashom
					if (not $TOM::Net::HTTP::UserAgent::table[$main::UserAgent]{agent_type}=~/browser/)
					{
						$key=$tom::code_key_root;
					}
					
					main::_log("encoded part is coded by key '$key'");
					
					my $link_hash=TOM::Net::URI::URL::hash_encode($var,$key);
					
					$rewrite=~s|&|&amp;|g unless $TOM::type_code;
					$link="$rewrite?$link_hash";
				}
				else
				{
					$rewrite=~s|&|&amp;|g unless $TOM::type_code;
					$link="$rewrite";
				}
				
				main::_log("URL='$rewrite_domain/$link'");
				
				my $URI_base=$rewrite_domain || $tom::H_www_orig;
					$URI_base=~s|$tom::rewrite_RewriteBase$||;
				my $URI_enh="$tom::rewrite_RewriteBase$link";
				$URI_base.='/' unless $URI_enh=~/^\//;
				
#				main::_log("301 from '$ENV{HTTP_HOST}$ENV{REQUEST_URI}' to '$URI_base$tom::rewrite_RewriteBase$link' (301.conf)",3,"pub.301",1);
#				main::_log("301 from '$ENV{HTTP_HOST}$ENV{REQUEST_URI}' to '$URI_base$tom::rewrite_RewriteBase$link' (301.conf)",3,"pub.301");
#				main::_log("301 from '$ENV{HTTP_HOST}$ENV{REQUEST_URI}' to '$URI_base$tom::rewrite_RewriteBase$link' (301.conf)");
				
				$t_301->close();
				$t_preprocess->close();
				$t_eval->close();
				$t_request->close();
				TOM::Debug::pub::request(
					'duration' => $t_eval->{'time'}{'duration'},
					'user' => $t_eval->{'time'}{'user'}{'duration'},
					'sys' => $t_eval->{'time'}{'sys'}{'duration'},
					'code' => '301',
					'location' => $URI_base.$tom::rewrite_RewriteBase.$link
				);
				print "Status: 301 Moved permanently\n";
				print "C3-Request: $main::request_code\n";
				print "Location: $URI_base$tom::rewrite_RewriteBase$link\n\n";
				
#				if ($TOM::CACHE && $TOM::CACHE_memcached){$Ext::CacheMemcache::cache->set('namespace'=>"c3process",'key' => $TOM::hostname.':'.$$,'value' => {'time' => time(),'start' => $TOM::time_start,'count' => $tom::count});}
				next;
			}
			
			my $link=$out;
			
			my $URI_base=$tom::H_www;
				$URI_base=~s|$tom::rewrite_RewriteBase$||;
			my $URI_enh="$tom::rewrite_RewriteBase$link";
			$URI_base.='/' unless $URI_enh=~/^\//;
			
#			main::_log("301 from '$ENV{HTTP_HOST}$ENV{REQUEST_URI}' to '$URI_base$tom::rewrite_RewriteBase$link' (301.conf)",3,"301",1);
#			main::_log("301 from '$ENV{HTTP_HOST}$ENV{REQUEST_URI}' to '$URI_base$tom::rewrite_RewriteBase$link' (301.conf)",3,"301");
#			main::_log("301 from '$ENV{HTTP_HOST}$ENV{REQUEST_URI}' to '$URI_base$tom::rewrite_RewriteBase$link' (301.conf)");
			
			$t_301->close();
			$t_preprocess->close();
			$t_eval->close();
			$t_request->close();
			TOM::Debug::pub::request(
				'duration' => $t_eval->{'time'}{'duration'},
				'user' => $t_eval->{'time'}{'user'}{'duration'},
				'sys' => $t_eval->{'time'}{'sys'}{'duration'},
				'code' => '301',
				'location' => $URI_base.$tom::rewrite_RewriteBase.$link
			);
			print "Status: 301 Moved permanently\n";
			print "C3-Request: $main::request_code\n";
			print "Location: $URI_base$tom::rewrite_RewriteBase$link\n\n";
			
#			if ($TOM::CACHE && $TOM::CACHE_memcached){$Ext::CacheMemcache::cache->set('namespace'=>"c3process",'key' => $TOM::hostname.':'.$$,'value' => {'time' => time(),'start' => $TOM::time_start,'count' => $tom::count});}
			next;
		}
		
		
		
		
		
		
		
		#############################################################################
		###### DOKONCENA PRACA S QUERY STRINGOM
		#############################################################################
		
		foreach (keys %FORM)
		{
#			$FORM{$_}=~s/<#?\$(.*?)>//;
		}
		
		
		# chcem log do outputu (ak budu splnene dalsie podmienky)
		
		# skusanie kluca IAdm_key
#		if ($FORM{__key})
#		{
#			$FORM{__key}=~s|[\n\r]||g;
#			if ($FORM{__key} eq $TOM::IAdm_key)
#			{
#				$IAdm=1;
#				main::_log("now I'am in IAdm mode");
#			}
#			elsif ($FORM{__key} eq $TOM::ITst_key)
#			{
#				$ITst=1;
#				main::_log("now I'am in ITst mode");
#			}
#			else
#			{
#				# zmazem kluc aby ked je neplatny, nebol noseny v query dalej
#				main::_log("FORM{__key} and TOM::IAdm_key not equals");
#				main::_log("FORM{__key}='$FORM{__key}'");
#				main::_log("TOM::IAdm_key='$TOM::IAdm_key'");
#				delete $FORM{__key};
#				delete $FORM{__key_file};
#				delete $FORM{__IAdm_log};
#			};
#		}
		
		
		
		# TAHAM KONFIGURACIU CACHE VZDY KED VYVOLAM ZMENOU JEJ RELOAD
		if (($TOM::CACHE)&&
			(Tomahawk::Getvar('_cache_conf_reload')>$TOM::time_start)&&
			(Tomahawk::Getvar('_cache_conf_reload')<$tom::time_current))
		{
			main::_log("Getting CACHE_CONF, start-$TOM::time_start cur-$tom::time_current set-".
					Tomahawk::Getvar('_cache_conf_reload'));
	 		&Tomahawk::GetCACHE_CONF;
		}
		
		
		my $t_cookies=track TOM::Debug("Cookies");
		#main::_log("Get cookies");
		
		#  local %COOKIES;
		%main::COOKIES=();
		%main::COOKIES_save=();
		%main::COOKIES_all=();
		%main::COOKIES_all_save=();
		
		%main::COOKIES=&Net::HTTP::cookies::GetCookies if !$TOM::Net::HTTP::UserAgent::table[$main::UserAgent]{'cookies_disable'};
		%main::COOKIES_all=&Net::HTTP::cookies::GetAllCookies if !$TOM::Net::HTTP::UserAgent::table[$main::UserAgent]{'cookies_disable'};
		%COOKIES_all_save=%COOKIES_all;
		
#		foreach (keys %main::COOKIES_all)
#		{
#			main::_log("key $_='$main::COOKIES_all{$_}'");
#		}

		foreach (keys %main::COOKIES)
		{
			main::_log("key $_='$main::COOKIES{$_}'");
		}
		
		# nedostal som ziadne cookies (mozno je toto moj prvy request)
		# nastavujem, teda cookies na posielanie cez URL linku (zaroven sa vzdy i tak
		# budem snazit posielat cookies standardnou cestou)
		
#		foreach (keys %main::ENV)
#		{
#			main::_log("ENV $_=".$main::ENV{$_});
#		}
		
		if (
				(keys %main::COOKIES) == 0 &&
				(
					(keys %main::COOKIES_all)
#					|| ($TOM::Document::type ne "xml")
					|| ($main::ENV{'HTTP_CONNECTION'} ne "close") # risky to send 302 code
				)
				&& ($tom::addons{'a301'} != -1)
		)
		{
			main::_log("none cookies found, but looks like supported");
			
			
			my $user_md5=TOM::Digest::hash
			(
				$main::ENV{'REMOTE_ADDR'}.
				$main::ENV{'HTTP_USER_AGENT'}.
				'1'
			);
			
			main::_log("user and request md5_identificator='$user_md5'");
			
			my $cookies_try=$Ext::CacheMemcache::cache->get(
				'namespace' => "cookies_try",
				'key' => $user_md5
			);
			if ($cookies_try)
			{
				main::_log("this user can't have a cookies");
			}
			elsif
			(
				$TOM::Net::HTTP::UserAgent::table[$main::UserAgent]{'agent_type'}=~/browser/
				&& !$TOM::Net::HTTP::UserAgent::table[$main::UserAgent]{'cookies_disable'}
				&& $main::ENV{'X-Requested-With'} ne "XMLHttpRequest"
			)
			{
				main::_log("trying to setup cookies");
				main::_log("setup cookies (IP='$main::ENV{'REMOTE_ADDR'}' UserAgent='$main::UserAgent_name'), redirect with 302 code",3,"a301",2);
				
				$Ext::CacheMemcache::cache->set(
					'namespace' => "cookies_try",
					'key' => $user_md5,
					'value' => 1,
					'expiration' => '60S'
				);
				
				$COOKIES{'_lt'}=$main::time_current;
				TOM::Engine::pub::cookies::send();
				
				my %form=TOM::Net::HTTP::CGI::get_CGI($main::ENV{'QUERY_STRING_FULL'});
				foreach ('ref','gclid','utm_medium','utm_source','utm_campaign','utm_content','utm_term')
				{delete $form{$_};}
				
				my ($rewrite_domain,$rewrite)=TOM::Net::URI::rewrite::parse_hash(\%form) if $tom::rewrite;
					$rewrite="/".$rewrite if $tom::rewrite;
					
				my $var=TOM::Net::URI::URL::genGET(%form);
				my $link_hash=$var;
				$link_hash=TOM::Net::URI::URL::hash_encode($var) if $TOM::type_code;
				my $link="$rewrite";$link.="?".$link_hash if $link_hash;
				
				# hack for Google AdWords (to save 'gclid' in QUERY_STRING)
				# hack for another campaings (to save 'ref' in QUERY_STRING)
				if ($FORM{'ref'}){$FORM{'utm_medium'}=$FORM{'ref'};delete $FORM{'ref'}};
				foreach ('gclid','utm_medium','utm_source','utm_campaign','utm_content','utm_term')
				{
					if ($FORM{$_})
					{if ($link=~/\?/){$link.="&".$_."=".$FORM{$_};}
					else{$link.="?".$_."=".$FORM{$_};$link_hash=1;}};
				}
				
				$link="" if $link eq "/";
				
				my $URL_orig=$tom::H_www_orig;
					my $rq_uri=$main::ENV{'REQUEST_URI'};
						$rq_uri=~s|^(.*?)[\?&].*$|$1|;
						$rq_uri=~s|$tom::rewrite_RewriteBase||;
						$rq_uri=~s|^/||;
					$URL_orig.='/'.$rq_uri if $rq_uri;
					$URL_orig.='?'.$main::ENV{'QUERY_STRING'} if $main::ENV{'QUERY_STRING'};
				my $URL=($rewrite_domain || $tom::H_www).$link;
				
#				main::_log("302 '$URL_orig' to '$URL' (trying setup cookies) IP='$ENV{REMOTE_ADDR}' USER_AGENT='$ENV{'HTTP_USER_AGENT'}'",3,"pub.301",1);
#				main::_log("302 '$URL_orig' to '$URL' (trying setup cookies) IP='$ENV{REMOTE_ADDR}' USER_AGENT='$ENV{'HTTP_USER_AGENT'}'",3,"pub.301");
#				main::_log("302 '$URL_orig' to '$URL' (trying setup cookies) IP='$ENV{REMOTE_ADDR}' USER_AGENT='$ENV{'HTTP_USER_AGENT'}'");
				
				$t_cookies->close();
				$t_preprocess->close();
				$t_eval->close();
				$t_request->close();
				TOM::Debug::pub::request(
					'duration' => $t_eval->{'time'}{'duration'},
					'user' => $t_eval->{'time'}{'user'}{'duration'},
					'sys' => $t_eval->{'time'}{'sys'}{'duration'},
					'code' => '302',
					'location' => $URL
				);
				print "Status: 302 Found\n";
				print "C3-Request: $main::request_code\n";
				print "Location: $URL\n\n";
				
#				if ($TOM::CACHE && $TOM::CACHE_memcached){$Ext::CacheMemcache::cache->set('namespace'=>"c3process",'key' => $TOM::hostname.':'.$$,'value' => {'time' => time(),'start' => $TOM::time_start,'count' => $tom::count});}
				next;
			}
			else
			{
				main::_log("for this user_agent i can't try to setup cookies");
			}
		}
		else
		{
			#main::_log("cookies");
		}
		
		%COOKIES_save=%COOKIES;
		
		$t_cookies->close();
		
		
		# LOKALIZUJEM PROSTREDIE pre KAZDY REQUEST
		local $H=$main::H_clone->clone();
		
		# DEFAULT DESIGN A LANGUAGE PROSTREDIA
		# $tom::dsgn_ - poziadavka
		# $tom::dsgn - tento request
		# $tom::DSGN - default
		local $tom::dsgn_=$tom::dsgn=$tom::DSGN;
		local $tom::lng_=$tom::lng=$tom::LNG;
		
		
		local %USRM;
		
		
		# ak nemam ulozeny ziadny jazyk v cookies a autodetekcia je zapnuta...
		if (!$COOKIES{_lng} && $TOM::LNG_autodetect)
		{
			main::_log("!COOKIES{_lng} and TOM::LNG_autodetect is enabled, autodetecting tom::lng_");
			# tak detekovany jazyk ulozim do requestu na zmenu jazyka $tom::lng_
			# (na konci stranky requestovany jazyk $tom::lng_ ukladam do Cookies)
			$tom::lng_=TOM::Int::lng::browser_autodetect($ENV{HTTP_USER_AGENT});
		}
		
		# poziadavka na dany design je default design v cookies (aj GETcookies)
		$tom::dsgn_=$COOKIES{_dsgn} if $COOKIES{_dsgn};
		$tom::lng_=$COOKIES{_lng} if $COOKIES{_lng};
		# zamena poziadavky na design z GetQuery (vyvolany v linku)
		$tom::dsgn_=$COOKIES{_dsgn}=$FORM{_dsgn} if $FORM{_dsgn};
		$tom::lng_=$COOKIES{_lng}=$FORM{_lng} if $FORM{_lng};
		
		# is If-Modified-Since header present?
		if ($main::ENV{'HTTP_IF_MODIFIED_SINCE'}=~/^(.*?), (\d+) (.*?) (\d+) (\d+):(\d+):(\d+) GMT$/)
		{
			my $user_session_modified;
			
			# converd datetime to timestamp
			my %months=("Jan"=>1,"Feb"=>2,"Mar"=>3,"Apr"=>4,"May"=>5,"Jun"=>6,"Jul"=>7,"Aug"=>8,"Sep"=>9,"Oct"=>10,"Nov"=>11,"Dec"=>12);
			use DateTime;
			my $date = DateTime->new(
				'year' => $4,
				'month' => $months{$3},
				'day' => $2,
				'hour' => $5+0,
				'minute' => $6+0,
				'second' => $7+0,
				'time_zone' => 'GMT');#->subtract( days => $env{'days'} );
			my $date_timestamp=$date->epoch();
			
			main::_log("HTTP_IF_MODIFIED_SINCE='$main::ENV{'HTTP_IF_MODIFIED_SINCE'}'/$date_timestamp HTTP_IF_NONE_MATCH/Etag='$main::ENV{'HTTP_IF_NONE_MATCH'}'");
			
#			main::_log("HTTP_IF_MODIFIED_SINCE='$main::ENV{'HTTP_IF_MODIFIED_SINCE'}'/$date_timestamp HTTP_IF_NONE_MATCH/Etag='$main::ENV{'HTTP_IF_NONE_MATCH'}' '$main::ENV{QUERY_STRING_FULL}' '$main::ENV{'HTTP_USER_AGENT'}'",3,"debug");
			
			my $usrmevent_timestamp;
			if ($main::COOKIES{'usrmevent'}=~/^(\d\d\d\d)\-(\d\d)\-(\d\d) (\d\d):(\d\d):(\d\d)$/)
			{
				my $date = DateTime->new(
					'year' => $1,
					'month' => $2,
					'day' => $3,
					'hour' => $4,
					'minute' => $5,
					'second' => $6,
					'time_zone' => 'local');#->subtract( days => $env{'days'} );
				$usrmevent_timestamp=$date->epoch();
				
#				main::_log("usrmevent: $usrmevent_timestamp ($main::COOKIES{'usrmevent'}) <=> cached at:$date_timestamp ($main::ENV{'HTTP_IF_MODIFIED_SINCE'})",3,"debug");
				if ($usrmevent_timestamp > $date_timestamp)
				{
					# to reindex
#					main::_log("user changed login after cached",3,"debug");
					$user_session_modified=1;
				}
				else
				{
#					main::_log("no user activity (login)",3,"debug");
				}
			}
			
			if (!$user_session_modified)
			{
				# okay, process etag
				
				my $etag=$main::ENV{'HTTP_IF_NONE_MATCH'};
				use MIME::Base64;
				$etag=decode_base64($etag);
				my $etag_valid;
				
				my $page_usecached=1;
				foreach my $etag_part(split(';',$etag))
				{
					if ($etag_part=~s/^E:://)
					{
						$etag_valid=1;
						my @entity=split('::',$etag_part);
						my $changetime=App::020::SQL::functions::_get_changetime({
							'db_h'=>"main",'db_name'=>$entity[0],'tb_name'=>$entity[1],
							'ID_entity' => $entity[2]
						});
						$changetime=int($changetime);
						if ($changetime > $date_timestamp)
						{
							# entity changed
#							main::_log("changed $changetime(entity) >= $date_timestamp(query)",3,"debug");
							$page_usecached=0;
							last;
						}
					}
					elsif ($etag_part=~/^max-age:(\d+)$/)
					{
						$etag_valid=1;
						my $max_age=$1;
						if ($date_timestamp < time()-$max_age )
						{
#							main::_log("cache page duration expired",3,"debug");
							$page_usecached=0;
							last;
						}
					}
					elsif ($etag_part=~/^valid-to:(\d+)$/)
					{
						$etag_valid=1;
						my $valid_to=$1;
						if (time() >= $valid_to)
						{
#							main::_log("cache page is not already valid",3,"debug");
							$page_usecached=0;
							last;
						}
					}
				}
				
				if (!$etag_valid)
				{
#					main::_log("page cache without Etag, expire",3,"debug");
#					# etag not available or no check inside
#					# also... apply default recache
#					if ($date_timestamp < time()-$TOM::CACHE_time)
#					{
#						main::_log("cache page has been expired by default cache time ($TOM::CACHE_time)",3,"debug");
						$page_usecached=0;
#					}
#					else
#					{
#						main::_log("cache page time remaining (".($TOM::CACHE_time-(time()-$date_timestamp)).")",3,"debug");
#					}
				}
				
				if ($page_usecached)
				{
#					main::_log("304 Not Modified",3,"debug");
					# entity not changed
					main::_log("[page][".$main::ENV{'HTTP_IF_NONE_MATCH'}."][HIT]",3,"cache");
					main::_log("[page][$tom::H][".$main::ENV{'HTTP_IF_NONE_MATCH'}."][HIT]",3,"cache",1);
					
					if ($Ext::Redis::service)
					{
						my $date_str=$tom::Fyear.'-'.$tom::Fmon.'-'.$tom::Fmday.' '.$tom::Fhour.':'.$tom::Fmin;
#						$Ext::Redis::service->hincrby('C3|counters|page_cache|'.$date_str,'crt',1,sub{});
						$Ext::Redis::service->hincrby('C3|counters|page_cache|'.$date_str,'hit',1,sub{});
						$Ext::Redis::service->expire('C3|counters|page_cache|'.$date_str,3600,sub{});
					}
					
					$t_preprocess->close();
					$t_eval->close();
					$t_request->close();
					TOM::Debug::pub::request(
						'duration' => $t_eval->{'time'}{'duration'},
						'user' => $t_eval->{'time'}{'user'}{'duration'},
						'sys' => $t_eval->{'time'}{'sys'}{'duration'},
						'code' => '304'
					);
					
					do
					{
						my $e_r=$t_eval->{'time'}{'req'}{'duration'};
						my $e_p=$t_eval->{'time'}{'proc'}{'duration'};
						if ($Ext::Redis::service)
						{
							my $date_str=$tom::Fyear.'-'.$tom::Fmon.'-'.$tom::Fmday.' '.$tom::Fhour.':'.$tom::Fmin;
							$Ext::Redis::service->hincrby('C3|counters|pub_bench|'.$TOM::hostname.'|'.$date_str,
								'cnt',1,sub{});
#							$Ext::Redis::service->hincrby('C3|counters|pub_bench|'.$TOM::hostname.'|'.$date_str,
#								'pre_req',$t_preprocess->{'time'}{'req'}{'duration'}*1000,sub{});
#							$Ext::Redis::service->hincrby('C3|counters|pub_bench|'.$TOM::hostname.'|'.$date_str,
#								'pre_proc',$t_preprocess->{'time'}{'proc'}{'duration'}*1000,sub{});
							$Ext::Redis::service->hincrby('C3|counters|pub_bench|'.$TOM::hostname.'|'.$date_str,
								'eval_req',int($e_r*1000),sub{});
							$Ext::Redis::service->hincrby('C3|counters|pub_bench|'.$TOM::hostname.'|'.$date_str,
								'eval_proc',int($e_p*1000),sub{});
						}
					};
					
#					main::_log("ID_user='".($main::USRM{'ID_user'} || $main::USRM{'IDhash'} || '        ').":".($main::USRM{'logged'} || ' ')."' IP='".($main::ENV{'REMOTE_ADDR'})."' QUERY='$main::ENV{QUERY_STRING_FULL}' REFERER='$main::ENV{HTTP_REFERER}' UserAgent='$main::UserAgent_name'",3,'pub.track');
					
					print "Status: 304 Not Modified\n\n";
					
#					if ($TOM::CACHE && $TOM::CACHE_memcached){$Ext::CacheMemcache::cache->set('namespace'=>"c3process",'key' => $TOM::hostname.':'.$$,'value' => {'time' => time(),'start' => $TOM::time_start,'count' => $tom::count});}
					next;
				}
				
#				else
#				{
#					main::_log("no Etag info, also recache",3,"debug");
	#				main::_log("[page][".$etag."][HIT]",3,"cache");
	#				main::_log("[page][$tom::H][".$etag."][HIT]",3,"cache",1);
	#				$t_preprocess->close();
	#				$t_eval->close();
	#				$t_request->close();
	#				Tomahawk::stat::rqs('proc' => $t_eval->{'time'}{'proc'}{'duration'},'req' => $t_eval->{'time'}{'req'}{'duration'});
	#				print "Status: 304 Not Modified\n\n";
	#				next;
#				}
				
				
				
			}
			
		}
		
		if ($TOM::LNG_permanent)
		{
			my $t=track TOM::Debug("LNG_permanent");
			#main::_log("attribute LNG_permanent is enabled");
			#
			# takze popis
			#
			# FORM{__lng}
			# z GET riadku dostavam poziadavky na jazyk v premennej FORM{__lng}, tato premenna
			# kedze ma __ sa prenasa po webe dalej v takom tvare v akom bola prijata, takze
			# sa generuje do kazdej dalsej linky automaticky.
			# premenna moze byt prazdna len na titulke, potom je nutne ju vyplnit defaultnym jazykom webu
			# (robi core.tom automaticky)
			#
			# $tom::lng_
			# je premenna v ktorej je automaticky evidovany request na jazyk.
			# ten je ziskany bud z Cookies alebo autodetekciou.
			# autodetekcia sa robi ak v Cookies nic nieje a je zapnuta autodetekcia.
			# pokial nieje zapnuta autodetekcia a v Cookies nic nieje v tejto premennej je
			# defaultny jazyk webu ($tom::LNG -> vid. local.conf)
			#
			#
			#
			
			#
			# Takze pokial som na titulnej strane webu (!$main::FORM{'__lng'}) ...
			# jazyk pre dalsie prenasanie do URL liniek si nastavim ako
			# requestovany jazyk ($tom::lng_) (akceptujem ho pre dalsie linky)
			# ktory je bud
			# a) aky bol autodetekciou zisteny
			# b) aky bol ulozeny v Cookies z predchadzajucej session a je ako request
			#
			main::_log("lng_ is '$tom::lng_'");
			
			$main::FORM{'__lng'}=$tom::lng_ unless $main::FORM{'__lng'};
			
			main::_log("set FORM{'__lng'} to '$main::FORM{'__lng'}'");
			
			if ($TOM::LNG_permanent_accepted)
			{
				my $i;foreach (@TOM::LNG_accept){$i=1 if $_ eq $main::FORM{'__lng'}}
				if (!$i)
				{
					$main::FORM{'__lng'}=$tom::lng;
				}
				main::_log("attribute LNG_permanent_accepted is enabled");
				main::_log("set FORM{'__lng'} to '$main::FORM{'__lng'}'");
				
				# spracovanie a210_path
				# a210_path funguje len v pripade ak je 100% jasne definovany jazyk
				# ktory bude platny v ramci requestu uz z parametrov (GET,rewrite)
				# Inak nieje mozne hladat a210_path v databaze podla jazyku
				
				if ($tom::a210)
				{
					my $t_a210=track TOM::Debug('a210:'.$main::FORM{'a210_path'});
					my %sql_def=('db_h' => "main",'db_name' => $App::210::db_name,'tb_name' => "a210_page");
					
					# ziskanie dat o Sitemap node
					# toto len v pripade ak uz nieje nastavene type z GET na nieco ine ako 'default' type
					if (!$main::FORM{'a210_name'} && !$main::FORM{'a210_path'} && (!$main::FORM{'type'} || $main::FORM{'type'} eq "default"))
					{
						main::_log("finding default");
						my $ID=App::210::SQL::page_get_default_ID('lng'=>$main::FORM{'__lng'});
						main::_log("default ID=$ID");
						%a210=App::020::SQL::functions::get_ID(
							%sql_def,
							'ID'      => $ID,
							'columns' => { '*' => 1 },
							'-slave' => 1,
							'-cache' => 600,
							'-cache_changetime' => App::020::SQL::functions::_get_changetime(\%sql_def)
						);
						if ($App::210::node_metadata_parse)
						{
							%{$a210{'metatree'}}=App::020::functions::metadata::parse($a210{'metadata'});
							delete $a210{'metadata'};
						}
						$main::a210{'node'}=\%a210;
						# musim vygenerovat default path pre automaticky 301 code
						foreach my $p(
							App::020::SQL::functions::tree::get_path(
								$ID,
								%sql_def,
								'columns' => { '*' => 1 },
								'-slave' => 1,
								'-cache' => 600
							)
						)
						{
							my $cvml = new CVML(data=>$p->{'t_keys'});
							foreach (grep {$_=~/^_/} keys %{$cvml->{'hash'}}) # cascading keys
							{
								$key{$_}=$cvml->{'hash'}->{$_};
								main::_log("t_key set '$_'='$key{$_}'");
							}
							if ($App::210::node_metadata_parse)
							{
								%{$p->{'metatree'}}=App::020::functions::metadata::parse($p->{'metadata'});
							}
							push @{$a210{'IDs'}}, $p->{'ID'};
							push @{$a210{'nodes'}}, $p;
							$main::FORM{'a210_path'}.="/".$p->{'name_url'};
						}
						$main::FORM{'a210_path'}=~s|^/||;
						if ($main::FORM{'a210_path'})
						{
							main::_log("path='$main::FORM{'a210_path'}'");
						}
						else
						{
							delete $main::FORM{'a210_path'};
							if ($tom::type_c{'homepage'}) # use 'homepage' instead of 'default' when available
							{
								$main::FORM{'type'}='homepage';
							}
						}
						# redirection bude '303' - bude ale vzdy?
						$main::location_code='302';
						$main::location_code='303' if scalar @TOM::LNG_accept > 1;
					}
					elsif ($main::FORM{'a210_path'} || $main::FORM{'a210_name'})
					{
						
						if ($main::FORM{'a210_name'})
						{
							my %sth0=TOM::Database::SQL::execute(qq{
								SELECT
									*
								FROM
									`$App::210::db_name`.a210_page
								WHERE
									status = 'Y'
									AND name_url = ?
									AND lng = ?
								ORDER BY
									ID_charindex
								LIMIT 1
							},'bind'=>[$main::FORM{'a210_name'},$main::FORM{'__lng'}],
								'-slave' => 1,
								'-cache' => 600,
								'-cache_changetime' => App::020::SQL::functions::_get_changetime(\%sql_def)
							);
							%a210=$sth0{'sth'}->fetchhash();
						}
						else #... find this path in a210
						{
							%a210=App::020::SQL::functions::tree::find_path_url(
								$main::FORM{'a210_path'},
								'db_h' => "main",
								'db_name' => $App::210::db_name,
								'tb_name' => "a210_page",
								'lng'     => $main::FORM{'__lng'},
								'columns' => { '*' => 1 },
								'-cache' => 600,
								'-slave' => 1
							);
						}
						
						main::_log("found a210_page.ID=$a210{'ID'} t_name='$a210{'t_name'}'");
						if ($App::210::node_metadata_parse)
						{
							%{$a210{'metatree'}}=App::020::functions::metadata::parse($a210{'metadata'});
#							$a210{'keys'} = new CVML(data=>$a210{'t_keys'});
							delete $a210{'metadata'};
#							delete $a210{'t_keys'};
						}
						$main::a210{'node'}=\%a210;
						foreach my $p(
							App::020::SQL::functions::tree::get_path(
								$a210{'ID'},
								'db_h' => "main",
								'db_name' => $App::210::db_name,
								'tb_name' => "a210_page",
								'columns' => { '*' => 1 },
								'-cache' => 600,
								'-slave' => 1,
							)
						)
						{
							my $cvml = new CVML(data=>$p->{'t_keys'});
							foreach (grep {$_=~/^_/} keys %{$cvml->{'hash'}}) # cascading keys
							{
								$key{$_}=$cvml->{'hash'}->{$_};
								main::_log("t_key set '$_'='$key{$_}'");
							}
							if ($App::210::node_metadata_parse)
							{
								%{$p->{'metatree'}}=App::020::functions::metadata::parse($p->{'metadata'});
							}
							delete $p->{'metadata'};
							push @{$a210{'IDs'}}, $p->{'ID'};
							push @{$a210{'nodes'}}, $p;
						}
						
						
						# spracovanie a210 dat
						if ($a210{'t_name'})
						{
							if ($main::FORM{'type'})
							{
								#main::_log("FORM{'type'} has been defined from GET, this link must be relinked by code 301");
								main::_log("FORM{'type'} already defined, a210{'t_name'} ignored");
								# tuto linku otestujem a spravim relokaciu podla kodu 301
								#$rewrite_301=1;
							}
							else
							{
								main::_log("set FORM{'type'}='$a210{'t_name'}'");
								$main::FORM{'type'}=$a210{'t_name'};
								$a210{'t_name_used'} = 1;
							}
						}
						
						my $cvml = new CVML(data=>$a210{'t_keys'});
						# a vytvor z neho hash
						#%key = %{$cvml->{'hash'}};
						foreach (keys %{$cvml->{'hash'}})
						{
							$key{$_}=$cvml->{'hash'}->{$_};
							main::_log("t_key set '$_'='$key{$_}'");
						}
						
						if (!$a210{'ID'})
						{
							main::_log("path '$main::FORM{'a210_path'}' not found in a210_page, searching in a210_page_j");
							%a210=App::020::SQL::functions::tree::find_path_url_j(
								$main::FORM{'a210_path'},
								'db_h' => "main",
								'db_name' => $App::210::db_name,
								'tb_name' => "a210_page",
								'lng'     => $main::FORM{'__lng'},
								'-cache' => 600,
								'-slave' => 1
							);
							if ($a210{'ID'})
							{
								delete $main::FORM{'a210_path'};
								$main::a210{'node'}=\%a210;
								# musim vygenerovat default path pre automaticky 301 code
								foreach my $p(
									App::020::SQL::functions::tree::get_path(
										$a210{'ID'},
										%sql_def,
										'columns' => { '*' => 1 },
										'-slave' => 1,
										'-cache' => 600
									)
								)
								{
									push @{$a210{'IDs'}}, $p->{'ID'};
									push @{$a210{'nodes'}}, $p;
									$main::FORM{'a210_path'}.="/".$p->{'name_url'};
								}
								$main::FORM{'a210_path'}=~s|^/||;
								if ($main::FORM{'a210_path'})
								{
									main::_log("path='$main::FORM{'a210_path'}'");
								}
								else
								{
									delete $main::FORM{'a210_path'};
								}
								
							}
							else
							{
								main::_log("page not found, setting 404 code");
								$main::page_statuscode="404"; # display 404 error
							}
						}
						
					}
					
					$a210{'path_url'}=$main::FORM{'a210_path'};
					
					$t_a210->close();
				}
				
			}
			
			
			#
			# nastavim ako requestovany jazyk ten ktory dostavam
			# permanentne a zaroven ho ukladam ako Cookie
			# (takze i v cookies je pri kazdom page rovnaky ako je celkovo request na jazyk)
			# clovek ktory pride znova na web ma request ($tom::lng_) taky isty
			# ako pri poslednej navsteve
			
			$tom::lng_=$main::COOKIES{'_lng'}=$main::FORM{'__lng'};
			
			$t->close();
		}
		
		
		# CODEPAGES
		$main::LNG_cp=$TOM::LNG_cp_default;
		$main::LNG_cp=$pub::LNG_cp if $pub::LNG_cp;
		# poziadavka od usera
		$main::LNG_cp_=$main::LNG_cp;
		$main::LNG_cp_=$main::COOKIES{_cp} if $main::COOKIES{_cp};
		$main::LNG_cp_=$COOKIES{_cp}=$FORM{_cp} if $FORM{_cp};
		
		
		
		########################
		# NARABANIE S TYPECKAMI
		########################
		
		# TID moze byt bud cislo (kvoli spetnej kompatibilite) alebo "g_nieco","l_nieco","m_nieco"
		# type moze byt hocico
		local $tom::Ptype=$tom::P; # cesta k typeckam
		local $tom::type;
		# convert type to TID
		$FORM{'TID.req'} = $FORM{'TID'} if $FORM{'TID'};
		undef $FORM{'TID'}; # don't allow to request TID directly
		if ($FORM{'type'})
		{
			if (!$tom::type_c{$FORM{'type'}} && $tom::type_c{'autoload'})
			{
				main::_log("FORM{'TID'} for FORM{'type'} does not exist, using defined autoload FORM{'TID'}");
				$FORM{'TID'}=$tom::type_c{'autoload'};
			}
			else
			{
				$FORM{'TID'}=$tom::type_c{$FORM{'type'}};
			}
			main::_log("FORM{type}='$FORM{'type'}' converted to FORM{'TID'}='$FORM{TID}'");
		}
		# tu je pre spetnu kompatibilitu tvar "[mg]0000"
		#if ($FORM{TID}=~/^([mg0-9])([0-9]+)$/)
		if ($FORM{TID}=~/^([mg0-9])([0-9]+)?$/)
		{
			main::_deprecated(0,"using bad format of TID '$1$2' from $ENV{HTTP_REFERER}");
			my $pre=$1;
			my $post=$2;
			if (not $pre=~/[lmg]/)
			{
				$post=$pre.$post;
				$pre="l";
			}
			$FORM{'TID'}=$pre."_".sprintf('%04d',$post);
		}
		# ak som dostal $FORM{typecko co sa neda prelozit
		# dalsi riadok by mal sposobit to, ze ak nebude preklad na TID, vyhlasi to chybu, treba vsak
		# nastavit statuscode na 404 aby sa jadro nepokusalo toto typecko nacitavat
		if (!$FORM{'TID'} && $FORM{'type'} && $FORM{'type'} ne "default")
		{
			# nastavenie 404 je nutne, inak by som sa nedostal vobec k citaniu l_notfound
			$main::page_statuscode="404";
			$FORM{'TID'}="l_".$FORM{'type'};
		}
		# ak je len TID poslane prazdne alebo zle
		else
		{
			$FORM{TID}="l_default" unless $FORM{TID}=~/^[lmg]_[0-9_\-a-zA-Z]{0,64}$/;
		}
#		if ($env{admin} eq "request"){$FORM{TID}="g_admin";}
#		if ($env{test} eq "request"){$FORM{TID}="g_test";}
		main::_log("type='$main::FORM{type}' TID='$main::FORM{TID}'($main::page_statuscode)");
		
		
		
		$t_preprocess->close();
		
		
		
		# dalej bude nasledovat poziadavka podla typecka,
		# ktora je nastavena nizsie
		
		###################################################################
		###################################################################
		###################################################################
		
		$pub::output_log=1;
		my $t_process=track TOM::Debug("processing TypeID='$FORM{TID}'",'timer'=>1);
		
		
		my $t_TypeID=track TOM::Debug("TypeID '$FORM{TID}'");
		# LOADUJEM DEFAULT TYPECKO V LOCALE AK HO NENAJDEM
		my $file_data;my $file_line;
		$tom::Ptype=do 
		{
			(($FORM{TID}=~/^(.)/)[0]) eq "g" ? $TOM::P :
			(($FORM{TID}=~/^(.)/)[0]) eq "m" ? $tom::Pm  :
			$tom::P ;
		};
		
		# najprv hladam subor so spravnym TYPE
#		main::_log("statuscode = $main::page_statuscode");
		if (($main::page_statuscode eq "200")&&(open (TYPE,"<".$tom::Ptype."/_type/".($FORM{TID}).".pub.type")))
		{
			main::_log("access to:".$tom::Ptype."/_type/".($FORM{TID}).".pub.type");
			local $/;$file_data=<TYPE>;
		}
		elsif (($main::page_statuscode eq "200")&&($main::FORM{'TID'}=~/^[lmg]_a(.*?)_/)&&(open (TYPE,"<".$tom::Ptype."/_addons/App/".$1."/_type/".($FORM{TID}).".pub.type")))
		{
			main::_log("access to:".$tom::Ptype."/_addons/App/".$1."/_type/".($FORM{TID}).".pub.type");
			local $/;$file_data=<TYPE>;
		}
		elsif (($main::page_statuscode eq "200")&&($main::FORM{'TID'}=~/^[lmg]_e(.*?)_/)&&(open (TYPE,"<".$tom::Ptype."/_addons/Ext/".$1."/_type/".($FORM{TID}).".pub.type")))
		{
			main::_log("access to:".$tom::Ptype."/_addons/Ext/".$1."/_type/".($FORM{TID}).".pub.type");
			local $/;$file_data=<TYPE>;
		}
#		elsif (($main::page_statuscode eq "200")&&($main::FORM{TID} =~/default/)&&(open (TYPE,"<".$tom::P."/_type/l_0000.pub.type")))
#		{
#			main::_deprecated("using bad TypeID file, $tom::P/_type/l_0000.pub.type");
#			local $/;$file_data=<TYPE>;
#		}
		# potom sa pokusam najst not_found page
		elsif (
			open (TYPE,"<".$tom::P."/_type/l_notfound.pub.type") ||
			open (TYPE,"<".$tom::Pm."/_type/m_notfound.pub.type") ||
			open (TYPE,"<".$TOM::P."/_type/g_notfound.pub.type") )
		{
			main::_log("loading: notfound.pub.type");
			local $/;$file_data=<TYPE>;
			$main::page_statuscode="404";
			if ($TOM::Net::HTTP::UserAgent::table[$main::UserAgent]{'agent_type'} ne "vandaliser"
				&& $TOM::Net::HTTP::UserAgent::table[$main::UserAgent]{'agent_type'} ne "spambot"
			)
			{
#				TOM::Error::engine(
#					"silent (This error message is in silen mode)",
#					"404, service type not found REQUEST_URI='$main::ENV{REQUEST_URI}' TID='$FORM{TID}'",
#					"Please check your type.conf, rewrite.conf or RewriteRules in .htaccess"
#				);
				$result="failed";
			}
		}
		else
		{
			do {die "Can't open TYPE file TID=$FORM{TID}\n";};
		}
		close(TYPE);
		
		$t_TypeID->close();
		
		
		# USRM check
		if ($tom::addons{'a301'} || $App::301::db_name)
		{
#			main::_log("[$tom::H] '$tom::addons{'a301'}' '$App::301::db_name'",3,"a301",2);
#			main::_log("[$tom::H] enabled",3,"a301",2) if $tom::addons{'a301'};
			if ($tom::addons{'a301'}==-1) # negative mode
			{
				# hardtyped into *.conf $tom::addons{'a301'} = -1;
				# negative mode not dissables a301 usage, but dissables USRM for all requests
			}
			else
			{
				App::301::session::process();
			}
		}
		
		# CITANIE HLAVICKY
		# PRIPRAVA TELA
		
#		# PRIDAVAM IAdm layer
#		$file_data="<CONF_VAR id=\"layers\" value=\"g0\" global=\"1\" />\n".$file_data if $IAdm;
#		$file_data="<CONF_VAR id=\"layers\" value=\"g1\" global=\"1\" />\n".$file_data if $ITst;
		
		
		#$TOM::type_pre=0;
		if ($TOM::type_pre)
		{
			my $data;
			if ($data=Tomahawk::Getvar("type_pre"))
			{
				#$file_data=$data."\n<#TYPE_PRE#>\n".$file_data;
			}
			else
			{
				open (HND,"<".$tom::P."/_type/pre.inc")
					|| open (HND,"<".$tom::P."/_type/pre.pub.type")
					|| open (HND,"<".$tom::P."/_type/pre.cml_type")
					|| open (HND,"<".$tom::Pm."/_type/mpre.cml_type")
					|| die "Cannot open PRE_TYPE file\n";
				my $line;while ($line=<HND>){$data.=$line;}
				close(HND);
				#$file_data=$data."\n<#TYPE_PRE#>\n".$file_data;
			}
			$file_data=$data."\n<#TYPE_PRE#>\n".$file_data;
		}
		
		
		#
		# CHECK_FORM variables
		#
		while ($file_data=~s|<CHECK_FORM (.*?)/>||)
		{
			my %env0=CML::VARhash($1);
			next unless $env0{'variable'};
			foreach (split(';',$env0{'variable'}))
			{
				$env0{'variable'}=$_;
				TOM::Security::form::check_form(%env0);
			}
		}
		
		
		#
		# KEYS TypeID
		#
		while ($file_data=~s|<CONF_KEY (.*?)/>||)
		{
			next unless $1; # vyhnem sa vykonavaniu dalsich podmienok
			my %env0=CML::VARhash($1);
			next unless $env0{'name'};
			next unless $env0{'default'};
			if (!$main::key{$env0{'name'}})
			{
				main::_log("t_key '$env0{'name'}' set to default value='$env0{'default'}'");
				if ($env0{'default'}=~/^<\$/)
				{
					TOM::Utils::vars::replace($env0{'default'});
					main::_log("re-set t_key '$env0{'name'}' to default value='$env0{'default'}'");
				}
				$main::key{$env0{'name'}}=$env0{'default'};
			}
		}
		
		$file_data=TOM::Utils::vars::replace_sec(
			$file_data,
			'notallow'=>['<MODULE','<VAR id']
		);
		
		#
		# CONF TypeID
		#
		$main::env{'https'}=0;
		while ($file_data=~s|<CONF_VAR (.*?)/>||)
		{
			next unless $1; # vyhnem sa vykonavaniu dalsich podmienok
			my %env0=CML::VARhash($1);
			next unless $env0{id};
			
			if ($env0{'id'} eq "doctype")
			{
				$main::ENV{'doctype'} = $env0{'value'};
			}
			
			if ($env0{'id'} eq "https" && $env0{'value'})
			{
				if ($env0{'value'} eq "required")
				{
					$main::env{'https'} = 'required';
				}
				elsif ($env0{'value'} eq "allowed")
				{
					$main::env{'https'} = 'allowed';
				}
				elsif ($env0{'value'} eq "notallowed")
				{
					$main::env{'https'} = 'notallowed';
				}
				_log("required https mode is '$main::env{'https'}'");
				next;
			}
			
			if($env0{'id'} eq "content_security_policy")
			{
				if($env0{'value'} eq "")
				{
					_log("Change content_security_policy to none");
					undef $TOM::Document::content_security_policy;
				}
				else
				{
					_log("Change content_security_policy to $env0{'value'}");
					$TOM::Document::content_security_policy = $env0{'value'};
				}
			}
			
			if($env0{'id'} eq "frame_options")
			{
				if ($env0{'value'})
				{
					_log("Change frame_options to $env0{'value'}");
					$TOM::Document::frame_options = $env0{'value'};
				}
			}
			
			if ($env0{'id'} eq "link")
			{
				if ($env0{'lng'}){next if $env0{'lng'} ne $tom::lng;}
				_log("Add to DOC::link");
				delete $env0{'id'};
				delete $env0{'lng'};
				$H->add_DOC_css_link(%env0);
				next;
			}
			
			if ($env0{'id'} eq "script")
			{
				if ($env0{'lng'}){next if $env0{'lng'} ne $tom::lng;}
				_log("Add to DOC::script");
				delete $env0{'id'};
				delete $env0{'lng'};
				$H->add_DOC_script(%env0);
				next;
			}
			
			if ($env0{'id'} eq "meta")
			{
				delete $env0{'id'};
				$main::H->add_DOC_meta(%env0);
				next;
			}
			
			next if (not defined $env0{'value'} && not defined $env0{'name'});
			# PODMIENKY
			
			
			if (
					(
						$env0{'id'} eq "header" ||
						$env0{'id'} eq "dsgn" # obsolete
					)
					&& not
					(
						($env0{'value'} eq $tom::DSGN)
						&& (!$env0{'global'})
					)
			)
			{
				local $main::DOC_BODY='';
				local %main::DOC_HEADER=();
				local %main::HEADER=();
				local $main::TEMPLATE='';
				my $var=$tom::P;
				if (($tom::Pm)&&($env0{'global'} eq "2")){$var=$tom::Pm;}
				if ($env0{'global'} eq "1"){$var=$TOM::P;}
				
				do $var."/_dsgn/".$env0{'value'}.".header"
					|| do $var."/_dsgn/".$env0{'value'}.".dsgn"
					|| die "Cannot import new design file named $env0{value}/$env0{global}\n";
				_log("Change design to ".$env0{'value'}."/".$env0{'global'});
				
				$main::DOC_BODY=$main::TEMPLATE if $main::TEMPLATE;
				%main::DOC_HEADER=%main::HEADER if %main::HEADER;
				
				$H=new TOM::Document(%DOC_HEADER);
				$H->i($main::DOC_BODY);
				$H->prepare();
				next;
			}
			
			if ((
						$env0{'id'} eq "body" ||
						$env0{'id'} eq "template" # obsolete
				)
				&& $env0{'value'})
			{
				local $main::DOC_BODY='';
				my $var=$tom::P;
				if (($tom::Pm)&&($env0{'global'} eq "2")){$var=$tom::Pm;}
				if ($env0{'global'} eq "1"){$var=$TOM::P;}
				
				main::_log("Loading body $var '".$env0{'value'}."/".$env0{'global'}."'");
				
				open (TMPL, '<'.$var.'/_dsgn/'.$env0{'value'}.'.body')
					|| open (TMPL, '<'.$var.'/_dsgn/'.$env0{'value'}.'.template')
					|| die "can't open body $env0{value}/$env0{global}";
				do
				{
					local $/;
					$main::DOC_BODY=<TMPL>
				};
				close(TMPL);
				
				undef $H->{'OUT'}{'BODY'};
				$H->i($main::DOC_BODY);
				
				next;
			}
			
			if (
					(
						$env0{'id'} eq "tpl"
						|| $env0{'id'} eq "template"
					)
					&& ($env0{'name'} || $env0{'value'})
				)
			{
				main::_log("Loading template $env0{'value'}");
				# load template
				$TPL=new TOM::Template(
					'level' => $env0{'level'},
					'name' => $env0{'name'} || $env0{'value'},
					'content-type' => $TOM::Document::type
				);
				next;
			}
			
			if ($env0{id} eq "log.level")
			{
				main::_log("Changing log.level='$env0{value}'");
				$TOM::DEBUG_log_file=$env0{'value'};
				main::_log("Changed log.level='$env0{value}'");
			}
			
			if (($env0{id} eq "xlng")&&($env0{value} ne $tom::LNG))
			{
				next unless $env0{value};
				
				my $i;foreach (@TOM::LNG_accept){$i=1 if $_ eq $env0{value}}
				if ($i)
				{
					$tom::lng=$env0{value};undef $tom::lang;
					main::_log("Change tom::lng (xlng) to '$env0{value}'");
				}
				else
				{
					main::_log("Language '$env0{value}' is not supported in \@TOM::LNG_accept");
				}
				
				next;
			}
			
			if ($env0{'id'} eq "title" && $env0{'value'})
			{
				if ($env0{'lng'}){next if $env0{'lng'} ne $tom::lng;}
				_log("Change DOC::title to ".$env0{'value'});
				$H->change_DOC_title($env0{'value'});
				next;
			}
			
			if ($env0{id} eq "sitemap")
			{
				_log("Change sitemap='".$env0{value}."'");
				$main::sitemap=$env0{value};
				next;
			}
			
			if ($env0{id} eq "changefreq")
			{
				_log("Set changefreq='".$env0{value}."'");
				$main::env{'changefreq'}=$env0{value};
				next;
			}
			
			if ($env0{id} eq "lastmod")
			{
				_log("Set lastmod='".$env0{value}."'");
				$main::env{'lastmod'}=$env0{value};
				next;
			}
			
			if ($env0{id} eq "weight")
			{
				_log("Set weight='".$env0{value}."'");
				$main::env{'weight'}=$env0{value};
				next;
			}
			
			if ($env0{id} eq "robots")
			{
				_log("Change robots='".$env0{value}."'");
				$main::H->change_DOC_robots($env0{value});
				next;
			}
			
			if ($env0{'id'} eq "title_" && $env0{'value'})
			{
				_log("Add to DOC::title to ".$env0{'value'});
				next if ($env0{'lng'} && $env0{'lng'} ne $tom::lng);
				$H->add_DOC_title($env0{'value'});
				next;
			}
			
			if ($env0{id} eq "keywords")
			{
				_log("Change DOC::keywords to ".$env0{value});
				next if ($env0{'lng'} && $env0{'lng'} ne $tom::lng);
				$H->change_DOC_keywords($env0{value});
				next;
			}
			
			if ($env0{id} eq "keywords_")
			{
				_log("Add DOC::keywords to ".$env0{value});
				next if ($env0{'lng'} && $env0{'lng'} ne $tom::lng);
				$H->add_DOC_keywords($env0{value});
				next;
			}
			
			if ($env0{id} eq "description")
			{
#				_log("Change DOC::description to ".$env0{value});
				next if ($env0{'lng'} && $env0{'lng'} ne $tom::lng);
				$H->change_DOC_description($env0{value},lng=>"$env0{lng}");
				next;
			}
			
			if ($env0{id} eq "description_")
			{
#				_log("Add DOC::description to ".$env0{value});
				next if ($env0{'lng'} && $env0{'lng'} ne $tom::lng);
				$H->add_DOC_description($env0{value},lng=>"$env0{lng}");
				next;
			}
			
			if ($env0{id} eq "css_link")
			{
				if ($env0{'lng'}){next if $env0{'lng'} ne $tom::lng;}
				_log("Add to DOC::css_link to ".$env0{value});
				my %env=TOM::Net::HTTP::CGI::get_QUERY_STRING($env0{'value'},'quiet'=>1);
				$H->add_DOC_css_link(%env);
				next;
			}
			
			# menim codepage
			if ($env0{id} eq "cp")
			{
				$main::LNG_cp=$env0{value};
				_log("Change main::LNG_cp (codepage) to ".$env0{value});
				next;
			}
			
			if (($env0{id} eq "xsgn")&&($env0{value} ne $tom::DSGN))
			{
				$tom::dsgn=$env0{value};
				_log("Change tom::dsgn (xsgn) to ".$env0{value});
				next;
			}
			
			if ($env0{id} eq "Content-Type")
			{
				$TOM::Document::content_type=$env0{value};
				_log("Change TOM::Document::content_type to ".$env0{value});
				next;
			}
			
			if ($env0{'id'} eq "ESI")
			{
				$main::ENV{'ESI'}=$env0{'value'};
#				delete $env0{'id'};
#				$main::H->set_ESI($env0{'value'});
				next;
			}
			
			if ($env0{'id'} eq "Expires")
			{
				if ($env0{'value'}=~/^\+(\d+)([DHMS])$/)
				{
					my $date = DateTime->now('time_zone' => 'GMT');#->subtract( days => $env{'days'} );
					if ($2 eq "D")
					{
						$date->add('days' => $1);
					}
					if ($2 eq "H")
					{
						$date->add('hours' => $1);
					}
					if ($2 eq "M")
					{
						$date->add('minutes' => $1);
					}
					if ($2 eq "S")
					{
						$date->add('seconds' => $1);
					}
					
					$main::ENV{'Expires'} = $date->strftime("%a, %d %b %Y %H:%M:%S GMT"); 
					
					_log("Change Expires to ".$main::ENV{'Expires'});
					next;
				}
			}
			
			if ($env0{'id'} eq "Cache-Control")
			{
				$main::ENV{'Cache-Control'}=$env0{'value'};
				_log("Change Cache-Control to ".$env0{'value'});
				next;
			}
			
#			if ($env0{'id'} eq "Pragma")
#			{
#				$main::ENV{'Pragma'}=$env0{'value'};
#				_log("Change Pragma to ".$env0{'value'});
#				next;
#			}
			
			if ($env0{'id'} eq "Etag")
			{
				use MIME::Base64;
				$main::ENV{'Etag'}=encode_base64($env0{'value'});
#				$main::ENV{'Etag'}=$env0{'value'};
				_log("Change Etag to ".$env0{'value'});
				next;
			}
			
			if ($env0{'id'} eq "env" && $env0{'type'})
			{
				_log("Change main::env ($env0{'type'}) to ".$env0{'value'});
				$main::env{$env0{'type'}}=$env0{value};
				next;
			}
			
			if ($env0{id} eq "FORM_reject")
			{
				if (
				 ($env0{'user_agent_type'} eq $TOM::Net::HTTP::UserAgent::table[$main::UserAgent]{'agent_type'})
				 ||(!$env0{'user_agent_type'}))
				{
					foreach (split(';',$env0{'value'}))
					{
						main::_log("FORM_reject '$_'");
						$FORM_reject{$_}++;
					}
				}
			}
			
			if (($TOM::LAYERS)&&(
					($env0{'id'} eq "layers")
					||($env0{'id'} eq "include")
					||($env0{'id'} eq "includes")
				)
			)
			{
				_log("Get layers/includes ".$env0{'value'});
				if (my $var=Tomahawk::layers::get('IDcategory'=>$env0{'value'}))
				{
					_log("including");
					Utils::vars::replace($var);
					next if $file_data=~s|<#TYPE_PRE#>|$var<#TYPE_PRE#>|s;
					$file_data=$var.$file_data;
				}
				next;
			}
		}
		
		# don't index this page when cache enabled globally, but disabled in this request
		$main::H->change_DOC_robots("noindex") if (!$main::cache && $TOM::CACHE);
		
		
		
		
		
		
		# testing variables for rejected in this TypeID
		foreach my $ex(keys %FORM_reject)
		{
			if ($ex=~s/\*$//)
			{
				foreach my $k(keys %FORM)
				{
					if ($k=~/^$ex/)
					{
						main::_log("delete rejected FORM key '$k'");
						delete $FORM{$k};
						$rewrite_301=1;
					}
				}
			}
			elsif ($FORM{$ex})
			{
				main::_log("delete rejected FORM key '$ex'");
				delete $FORM{$ex};
				$rewrite_301=1;
			}
		}
		
		# control if this URL is correct
		# $tom::rewrite - priznak ze je nacitany rewrite.conf
		# $tom::rewrite_301 - zapnuty rewrite 301 v local.conf
		# and if not displaying 404 error is not required
		if (
				$tom::rewrite &&
				$tom::rewrite_301 &&
				$ENV{'HTTP_HOST'} && # running under webserver
				$main::page_statuscode ne "404"
			)
		{
			my $t_301=track TOM::Debug("REQUEST_URI link testing for 300 redirection");
			
			main::_log("REQUEST_URI='$main::ENV{REQUEST_URI}' HTTPS=".$main::ENV{'HTTPS'}." H_www=".$tom::H_www." H_www_orig=".$tom::H_www_orig);
			
			my $link_old=$main::ENV{'REQUEST_URI'};
			my $rewrite_old=$main::ENV{'REQUEST_URI'};$rewrite_old=~s|^(.*)\?.*?$|$1|;
				$rewrite_old=~s|^$tom::rewrite_RewriteBase||;
			
			# pokus o vytvorenie rewrite linky
			main::_log("cleaning FORM variables");
			my %form=%FORM;
			delete $form{'TID'} if $form{'type'};
			delete $form{'TID'} if $form{'TID'} eq "l_default";
			delete $form{'type'} if $form{'type'} eq "default";
			delete $form{'cookies'};
			delete $form{'type'} if $a210{'t_name_used'}; # dont' paste to URL $form{'type'} when is defined by $a210{'t_name'}
			
			# path2name
			if ($App::210::path2name && $form{'a210_path'})
			{
				$form{'a210_name'}=$form{'a210_path'};
				delete $form{'a210_path'};
				$form{'a210_name'}=~s|^.*/||;
			}
			
			my ($rewrite_domain,$rewrite)=TOM::Net::URI::rewrite::parse_hash(\%form);
				$rewrite="/".$rewrite;
				$rewrite_domain=$rewrite_domain || do {
					if (
							$tom::H_www_https &&
							(
								(
									$main::ENV{'HTTPS'} eq "on"
									&& !$tom::H_www_https_onlyifrequired
								)
								||
								(
									$tom::H_www_https_onlyifrequired
									&& $main::env{'https'} eq "required"
								)
								||
								(
									$main::ENV{'HTTPS'} eq "on"
									&& $main::env{'https'} eq "allowed"
								)
							)
							&&
							$main::env{'https'} ne "notallowed"
					)
					{
						$tom::H_www_https
					}} || $tom::H_www_orig;
				
			main::_log("rewrited part is '$rewrite' domain '$rewrite_domain'");
			
			foreach (grep {defined $_->{'a210_path_prefix'}} @tom::H_www_multi)
			{
#				if ($a210_path=~/^$_->{'a210_path_prefix'}\//)
#				{
#					$a210_path=~s|^$_->{'a210_path_prefix'}/||;
#					$a210_path=~s|/$||;
#					$form{'a210_path'}=$a210_path;
#					$newlink_prefix=~s/(https?:\/\/)(.*?)\//$1.$_->{'H'}.'\/'/e;
#					main::_log("URL changed newlink_prefix='$newlink_prefix'") if $debug_url;
#					$tom::H_www_external=1;
#					last;
#				}
			}
			
			my $link;
			
			my $var='';
			if (keys %form > 0)
			{
				$var=TOM::Net::URI::URL::genGET(%form);
			}
			
			if
				(
					($TOM::type_code) # kodujem
					&&
					($var) # vo var vobec nieco je
					&&
					(
						# encodovat cast URI s premennymi len ak je v linke hashovana cast
						$main::ENV{'REQUEST_URI'}=~/^(.*)-(.*?)-v\d$/
					)
				)
			{
				my $key=$2;
				
				# v pripade ze som robot tak ked pridem na stranku linkou hashovanou pomocou
				# kluca ktory nieje urceny pre robota, tak sa presmerujem na linku len s takymto
				# hashom
				if ((not $TOM::Net::HTTP::UserAgent::table[$main::UserAgent]{agent_type}=~/browser/)
					&&($key ne $tom::code_key_root))
				{
					$key=$tom::code_key_root;
					$rewrite_301=1;
				}
				
				main::_log("encoded part is coded by key '$key'");
				
				my $link_hash=TOM::Net::URI::URL::hash_encode($var,$key);
				
#				$rewrite=~s|&|&amp;|g unless $TOM::type_code;
				$link="$rewrite?$link_hash";
			}
			else
			{
#				$rewrite=~s|&|&amp;|g unless $TOM::type_code;
				$link=$rewrite;
				$link.="?".$var if $var;
			}
			
			main::_log("link_old='$link_old' link='$link'");
			main::_log("H_www='$tom::H_www' rewrite_domain='$rewrite_domain' rewrite_old='$rewrite_old' rewrite='$rewrite'");
#			main::_log("H_www_orig='$tom::H_www_orig' H_www='$tom::H_www' rewrite_domain='$rewrite_domain' rewrite_old='$rewrite_old' rewrite='$rewrite'",3,"debug");
			
			if (($tom::H_www ne $rewrite_domain) || ($rewrite_old ne $rewrite) || $rewrite_301
#				|| (($link_old ne $link) &&
#				 ($main::ENV{'REQUEST_METHOD'} eq "GET"))
			)
			#if (($link_old ne $link) || $rewrite_301)
			{
				# musim odoslat cookies i ked robim relocation
				TOM::Engine::pub::cookies::send();
				
				# ide kod 301
#				main::_log("301 from '$ENV{HTTP_HOST}$ENV{REQUEST_URI}' to '$rewrite_domain$link' (test)",3,"pub.301",1);
#				main::_log("301 from '$ENV{HTTP_HOST}$ENV{REQUEST_URI}' to '$rewrite_domain$link' (test)",3,"pub.301");
#				main::_log("301 from '$ENV{HTTP_HOST}$ENV{REQUEST_URI}' to '$rewrite_domain$link' (test)");
				
				$t_301->close();
				$t_process->close();
				$t_eval->close();
				$t_request->close();

				$main::location_code='301' unless $main::location_code=~/^30.$/;

				TOM::Debug::pub::request(
					'duration' => $t_eval->{'time'}{'duration'},
					'user' => $t_eval->{'time'}{'user'}{'duration'},
					'sys' => $t_eval->{'time'}{'sys'}{'duration'},
					'code' => $main::location_code,
					'location' => $rewrite_domain.$link
				);
				print "Status: ".$main::location_code." Moved\n";
				print "C3-Request: $main::request_code\n";
				print "Location: $rewrite_domain$link\n\n";
				main::_log("Location: $rewrite_domain$link");
				
				untie %{$main::USRM{'session'}} if ref($main::USRM{'session'}) eq "HASH"; # DESTROY
				
#				if ($TOM::CACHE && $TOM::CACHE_memcached){$Ext::CacheMemcache::cache->set('namespace'=>"c3process",'key' => $TOM::hostname.':'.$$,'value' => {'time' => time(),'start' => $TOM::time_start,'count' => $tom::count});}
				next;
			}
			
			$t_301->close();
		}
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		# NEW LAYERS
		while ($file_data=~s|<(ADDLAYER\|INCLUDE) (.*?)/>|<!TMP!>|)
		{
			my %env0=CML::VARhash($2);
			my $var;
			_log("Importing layers ".$env0{id});
			if ($var=Tomahawk::layers::get(IDcategory=>$env0{id}))
			{
				_log("including");
				Utils::vars::replace($var);
			}
			$file_data=~s|<!TMP!>|$var|g;
		}
		
		
		# LOAD CACHE
		if ($main::env{'cache'} eq "dynamic")
		{
			# load cache if available
		}
		
		
		# Replace all variables available in document
		TOM::Utils::vars::replace($main::H->{'OUT'}{'HEADER'});
		TOM::Utils::vars::replace($main::H->{'OUT'}{'BODY'});
		
		
		
		my $var_replace;
		$var_replace=1 if $file_data=~s|<#\$|<\$|g; # priprava pre next data
		
		
		# VYKONAVANIE MODULOV
		while ($file_data=~s|<MODULE>(.*?)</MODULE>||s) # pre system vary maximalne 1024 znakov
		{
			last if $main::action eq "stop";
			
			my $data=$1;
			
			# tu som pridal novu konverziu :)
			TOM::Utils::vars::replace($data) if $var_replace;
			
			# v module ako -xlng pouzijem default $tom::lng
			
			my %mdl_env;
			while ($data=~s|<VAR id="(.{1,150}?)" (value\|get)="(.*?)" />||s)
			{
				next if not defined $3;
				if ($2 eq "get")
				{
					$mdl_env{$1}=$main::FORM{$3};
				}
				else
				{
					$mdl_env{$1}=$3;
					$mdl_env{$1}=~s|\"|"|g;
				}
			}
			
			main::_log("<={MODULE} ".$mdl_env{'-type'}.':'.($mdl_env{'-category'} || $mdl_env{'-addon'}).'-'.$mdl_env{'-name'}.' TMP:'.$mdl_env{'-TMP'});
			
			if (exists $mdl_env{'-enabled'} && !$mdl_env{'-enabled'})
			{
				main::_log("module not enabled");
				next;
			}
			
			if ($mdl_env{'-disabled'})
			{
				main::_log("module disabled");
				next;
			}
			
			$mdl_env{'-type'}=~/^mdl/ && do
			{
				module(%mdl_env);
				next;
			};
			
			$mdl_env{'-type'}=~/^smdl/ && do
			{
				supermodule(%mdl_env);
				next;
			};
			$mdl_env{'-type'}=~/^dmdl/ && do
			{
				designmodule(%mdl_env);
				next;
			};
			$mdl_env{'-type'}=~/^tpl/ && do
			{
				tplmodule(%mdl_env);
				next;
			};
			$mdl_env{'-type'}=~/^dget/ && do
			{
				module(%mdl_env);
				next;
			};
		}
		
		
		
		if ($main::location)
		{
#			$main::location_code='302';
			
			# musim odoslat cookies i ked robim relocation
			TOM::Engine::pub::cookies::send();
			
#			main::_log("ID_user='".($main::USRM{'ID_user'} || $main::USRM{'IDhash'} || '        ').":".($main::USRM{'logged'} || ' ')."' IP='".($main::ENV{'REMOTE_ADDR'})."' QUERY='$main::ENV{QUERY_STRING_FULL}' REFERER='$main::ENV{HTTP_REFERER}' UserAgent='$main::UserAgent_name'",3,'pub.track');
			
			my $out=$location;
			my $t_301=track TOM::Debug("redirect by main::location");
			if ($out=~/^-(\d+)/)
			{
				my $code=$1;
#				main::_log("code $1 on REQUEST_URI='$ENV{'REQUEST_URI'}' (location)",3,"pub.301",1);
#				main::_log("code $1 on REQUEST_URI='$ENV{'REQUEST_URI'}' (location)",3,"pub.301");
#				main::_log("code $1 on REQUEST_URI='$ENV{'REQUEST_URI'}' (location)",1);
				
				$t_301->close();
				$t_process->close();
				$t_eval->close();
				$t_request->close();
				TOM::Debug::pub::request(
					'duration' => $t_eval->{'time'}{'duration'},
					'user' => $t_eval->{'time'}{'user'}{'duration'},
					'sys' => $t_eval->{'time'}{'sys'}{'duration'},
					'code' => $code,
#					'location' => $out
				);
				print "Status: $code Unknown\n\n";
				untie %{$main::USRM{'session'}} if ref($main::USRM{'session'}) eq "HASH"; # DESTROY
				
#				if ($TOM::CACHE && $TOM::CACHE_memcached){$Ext::CacheMemcache::cache->set('namespace'=>"c3process",'key' => $TOM::hostname.':'.$$,'value' => {'time' => time(),'start' => $TOM::time_start,'count' => $tom::count});}
				next;
			}
			
			main::_log("$main::location_code redirect to '$out'");
			
			if ($out=~/^http/)
			{
				# ide kod 302
#				main::_log("$main::location_code from '$ENV{HTTP_HOST}$ENV{REQUEST_URI}' to '$out' (location)",3,"pub.301",1);
#				main::_log("$main::location_code from '$ENV{HTTP_HOST}$ENV{REQUEST_URI}' to '$out' (location)",3,"pub.301");
#				main::_log("$main::location_code from '$ENV{HTTP_HOST}$ENV{REQUEST_URI}' to '$out' (location)");
				
				$t_301->close();
				$t_process->close();
				$t_eval->close();
				$t_request->close();
				TOM::Debug::pub::request(
					'duration' => $t_eval->{'time'}{'duration'},
					'user' => $t_eval->{'time'}{'user'}{'duration'},
					'sys' => $t_eval->{'time'}{'sys'}{'duration'},
					'code' => $main::location_code,
					'location' => $out
				);
				print "Status: $main::location_code Found\n";
				print "C3-Request: $main::request_code\n";
				print "Location: $out\n\n";
				untie %{$main::USRM{'session'}} if ref($main::USRM{'session'}) eq "HASH"; # DESTROY
				
#				if ($TOM::CACHE && $TOM::CACHE_memcached){$Ext::CacheMemcache::cache->set('namespace'=>"c3process",'key' => $TOM::hostname.':'.$$,'value' => {'time' => time(),'start' => $TOM::time_start,'count' => $tom::count});}
				next;
			}
			
			if ($out=~/^\//)
			{
				# ide kod 302
#				main::_log("$main::location_code from '$ENV{HTTP_HOST}$ENV{REQUEST_URI}' to '$out' (location)",3,"pub.301",1);
#				main::_log("$main::location_code from '$ENV{HTTP_HOST}$ENV{REQUEST_URI}' to '$out' (location)",3,"pub.301");
#				main::_log("$main::location_code from '$ENV{HTTP_HOST}$ENV{REQUEST_URI}' to '$out' (location)");
				
				$t_301->close();
				$t_process->close();
				$t_eval->close();
				$t_request->close();
				TOM::Debug::pub::request(
					'duration' => $t_eval->{'time'}{'duration'},
					'user' => $t_eval->{'time'}{'user'}{'duration'},
					'sys' => $t_eval->{'time'}{'sys'}{'duration'},
					'code' => $main::location_code,
					'location' => $out
				);
				print "Status: $main::location_code Found\n";
				print "C3-Request: $main::request_code\n";
				print "Location: $out\n\n";
				if ($TOM::Document::ACAOrigin eq "dynamic")
				{
					my $aca = $main::ENV{'HTTP_REFERER'} || $tom::H_www;
						$aca =~s|^(http[s]?://.*?)/.*$|$1|;
					$aca=$main::ENV{'HTTP_ORIGIN'} if $main::ENV{'HTTP_ORIGIN'};
					print "Access-Control-Allow-Origin: ".$aca."\n";
					print "Vary: Origin\n";
				}
				else
				{
					print "Access-Control-Allow-Origin: ".($TOM::Document::ACAOrigin || '*')."\n";
				}
				print "Expires: ".$main::ENV{'Expires'}."\n" if $main::ENV{'Expires'};
				print "Cache-Control: ".$main::ENV{'Cache-Control'}."\n" if $main::ENV{'Cache-Control'};
				
				untie %{$main::USRM{'session'}} if ref($main::USRM{'session'}) eq "HASH"; # DESTROY
				
#				if ($TOM::CACHE && $TOM::CACHE_memcached){$Ext::CacheMemcache::cache->set('namespace'=>"c3process",'key' => $TOM::hostname.':'.$$,'value' => {'time' => time(),'start' => $TOM::time_start,'count' => $tom::count});}
				next;
			}
			
			if ($out=~s/^\?\|\?//)
			{
				main::_log("encoding URL");
				my %form=TOM::Net::HTTP::CGI::GetQuery($out,'-lite'=>1);
				foreach (keys %FORM){$_=~/^__/ && do{$form{$_}=$FORM{$_};};}
				foreach (keys %form)
				{
					main::_log("key '$_'='$form{$_}'");
				}
				
				my ($rewrite_domain,$rewrite)=TOM::Net::URI::rewrite::parse_hash(\%form);
					$rewrite="/".$rewrite;
				
				main::_log("rewrited part is '$rewrite' domain='$rewrite_domain'");
				my $link;
				my $var='';
				if (keys %form > 0)
				{
					$var=TOM::Net::URI::URL::genGET(%form);
				}
				main::_log("rewrite='$rewrite' URL='$var'");
				my $link;
				if
					(
						($TOM::type_code) # kodujem
						&&
						($var) # vo var vobec nieco je
#						&&
#						(
#							($IAdm && !$FORM{_IAdm_decode})
#							||
#							(!$IAdm)
#						)
#						&&
#						(
#							($ITst && !$FORM{_ITst_decode})
#							||(!$ITst)
#						)
					)
				{
					# defaultne lubovolny key
					my $key;
					# v pripade ze som robot tak ked pridem na stranku linkou hashovanou pomocou
					# kluca ktory nieje urceny pre robota, tak sa presmerujem na linku len s takymto
					# hashom
					if (not $TOM::Net::HTTP::UserAgent::table[$main::UserAgent]{agent_type}=~/browser/)
					{
						$key=$tom::code_key_root;
					}
					main::_log("encoded part is coded by key '$key'");
					my $link_hash=TOM::Net::URI::URL::hash_encode($var,$key);
					$link="$rewrite?$link_hash";
				}
				else
				{
					$link=$rewrite;
					$link.="?".$var if $var;
				}
				
				my $URI_base=$rewrite_domain || do {
					if ($main::ENV{'HTTPS'} eq "on" && $tom::H_www_https)
					{
						$tom::H_www_https
					}
				} || $tom::H_www_orig;
					$URI_base=~s|$tom::rewrite_RewriteBase$||;
				my $URI_enh="$tom::rewrite_RewriteBase$link";
				$URI_base.='/' unless $URI_enh=~/^\//;
				
				# nekodovana linka
#				$link=~s|&|&amp;|g unless $TOM::type_code;
				main::_log("URL='$link'");
#				main::_log("$main::location_code from '".($main::ENV{'HTTPS'})."//$ENV{HTTP_HOST}$ENV{REQUEST_URI}' to '$URI_base$tom::rewrite_RewriteBase$link' (location)",3,"pub.301",1);
#				main::_log("$main::location_code from '".($main::ENV{'HTTPS'})."//$ENV{HTTP_HOST}$ENV{REQUEST_URI}' to '$URI_base$tom::rewrite_RewriteBase$link' (location)",3,"pub.301");
#				main::_log("$main::location_code from '".($main::ENV{'HTTPS'})."//$ENV{HTTP_HOST}$ENV{REQUEST_URI}' to '$URI_base$tom::rewrite_RewriteBase$link' (location)");
				
				$t_301->close();
				$t_process->close();
				$t_eval->close();
				$t_request->close();
				TOM::Debug::pub::request(
					'duration' => $t_eval->{'time'}{'duration'},
					'user' => $t_eval->{'time'}{'user'}{'duration'},
					'sys' => $t_eval->{'time'}{'sys'}{'duration'},
					'code' => $main::location_code,
					'location' => $URI_base.$tom::rewrite_RewriteBase.$link
				);
				print "Status: $main::location_code Found\n";
				print "C3-Request: $main::request_code\n";
				print "Location: $URI_base$tom::rewrite_RewriteBase$link\n\n";
				untie %{$main::USRM{'session'}} if ref($main::USRM{'session'}) eq "HASH"; # DESTROY
				
#				if ($TOM::CACHE && $TOM::CACHE_memcached){$Ext::CacheMemcache::cache->set('namespace'=>"c3process",'key' => $TOM::hostname.':'.$$,'value' => {'time' => time(),'start' => $TOM::time_start,'count' => $tom::count});}
				next;
			}
			$t_301->close();
		}
		
		
		$t_process->close();
		
		
		foreach (keys %TOM::Debug::namespace)
		{
			main::_log
			(
				"benchmark namespace '$_' (time:".
						($TOM::Debug::namespace{$_}{'time'}{'req'}{'duration'}*1000).
						"ms user:~".
						($TOM::Debug::namespace{$_}{'time'}{'proc'}{'duration'}*1000).
						"ms)"
			) if $TOM::DEBUG_benchmark;
		}
		
		
		
		$pub::output_log=0;
		my $t_postprocess=track TOM::Debug("postprocess",'timer'=>1);
		
		
		if (!$COOKIES{'_lng'} && $TOM::LNG_autodetect)
		{
			main::_log("COOKIES{_lng}=tom::lng_ after autodect");
			$COOKIES{'_lng'}=$tom::lng_;
		}
		
		
		# mazem kluc pokial niesom v IAdm
#		if (
#			(
#				(!$ITst)&&
#				(!$IAdm)&&
#				(!$env{admin})&&
#				(!$env{test})
#			)
#			&& ($main::COOKIES{key} || $main::FORM{__key_} || $main::FORM{__key})
#		)
#		{
#			main::_log("deleted COOKIE{key} ITst:$ITst IAdm:$IAdm env{admin}:$env{admin} env{test}:$env{test}",0,"IAdm");
#			$main::COOKIES{key}="";
#			delete $main::FORM{__key_};
#			delete $main::FORM{__key};
#			delete $main::FORM{__key_file};
#			delete $main::FORM{__IAdm_log};
#		}
		
		
		
		
		
		my $t_urlreplace=track TOM::Debug('url replace','timer'=>1);
		my $url_count;
		# AUTOMATICKA ZAMENA LINKOV
		my $link;
		my $hash=Utils::vars::genhash(3);
		if (!$tom::rewrite)
		{
			$H->{'OUT'}{'BODY'}=~s/http:\/\/null\///g;
		}
		my $debug_url=0;
		%main::url_cache=();
		%main::pp=TOM::Net::HTTP::CGI::get_QUERY_STRING($main::ENV{'QUERY_STRING_FULL'},'quiet'=>1);
#		foreach (keys %main::FORM)
#		{
#			$main::pp{$_}=$main::FORM{$_};
#		}
		$H->{'OUT'}{'BODY'}=~s/$url_regexp/TOM::Document::base::url_replace($1,$2,$3)/eg;
		$t_urlreplace->close();
		
		
#		# vpisujem log :)
#		if (($IAdm)&&($FORM{__IAdm_log})){$H->r("<!TMP-IAdm-LOG!>",$IAdm_log);}
		
		if ($main::page_statuscode eq "404")
		{
			$main::H->change_DOC_robots("noindex,noarchive");
#			main::_log("404 REQUEST_URI='$ENV{'REQUEST_URI'}' QUERY='$ENV{'QUERY_STRING'}' Not Found for '$main::ENV{'REMOTE_ADDR'}' with '$main::ENV{'HTTP_USER_AGENT'}'",4,"pub.404");
		}
		if ($result eq "failed")
		{
			$main::H->change_DOC_robots("noindex,noarchive");
		}
		
		# calculate semi-speed
		$t_eval->semiclose();
		my $ID_user=$main::USRM{'ID_user'} || $main::USRM{'IDhash'};
		$H->{'OUT'}{'HEADER'}=~s/<%META-Cyclone3%>/req_load='$t_eval->{'time'}{req}{duration}';proc_load='$t_eval->{'time'}{proc}{duration}';ID_user='$ID_user';request='$main::request_code';host='$TOM::hostname';proc='$$'/;
		
		my $DOC_output;
		$H->prepare_last(result=>$result);
		
		
		if ($H->{'OUT'}{'BODY'})
		{
#			main::_log("Document not in UTF-8",1) unless utf8::is_utf8($H->{'OUT'}{'BODY'});
#			main::_log("Document not in UTF-8",1,"pub.err") unless utf8::is_utf8($H->{'OUT'}{'BODY'});
		}
		
		
		
#		$main::H->message("This document has been generated as requested for UserAgent \"".$main::UserAgent_name."\"");
		
		# ak je browser stary
		$main::H->message($TOM::Net::HTTP::UserAgent::messages{old}[$TOM::Net::HTTP::UserAgent::table[$main::UserAgent]{old}])if exists $TOM::Net::HTTP::UserAgent::table[$main::UserAgent]{old};
		
		# ak mam pre tento browser specialny message do zdrojoveho kodu stranky
		$main::H->message(@{$TOM::Net::HTTP::UserAgent::table[$main::UserAgent]{messages}}) if $TOM::Net::HTTP::UserAgent::table[$main::UserAgent]{messages};
		
		#$t_doc_output->close();
		
#		{my $t=track TOM::Debug("codepage settings");
			
			# pokial je vystup z publisheru ako PDF
			# musim prevadzat HTML document do lokalneho kodovania
			if ($TOM::Document::content_type eq "application/pdf")
			{
				$main::LNG_cp=$Cyclone::l10n::charset::lng_charset{$tom::lng};
				main::_log("codepage set to '$main::LNG_cp' because Content-Type='application/pdf' and language='$tom::lng'");
				$H->rh("<%CODEPAGE%>",$main::LNG_cp);
				$DOC_output=$H->OUT_;
				if ($main::LNG_cp =~/^(ASCII|ISO-8859-1)$/)
				{
					$DOC_output=Int::charsets::encode::UTF8_ASCII($DOC_output);
				}
				else
				{
					use Encode;
					$DOC_output = encode_utf8($DOC_output);
					Encode::from_to($DOC_output, $TOM::LNG_cp_default, $main::LNG_cp);
				}
				main::_log("output document converted to codepage '$main::LNG_cp' succesfully length=(".(length($DOC_output)).")");
				$main::cache='';$main::ENV{'Cache-Control'}='no-cache';
			}
			elsif (
					($main::LNG_cp ne $TOM::LNG_cp_default)
					&&($Cyclone::l10n::charset::list{$main::LNG_cp})
				)
				# ak chcem zobrazit web v inom kodovani nez UTF8
				# tak bez debaty vyhoviem (teda ak take kodovanie existuje) :)
			{
				main::_log("codepage set to '$main::LNG_cp' because requested");
				$COOKIES{cp}=$main::LNG_cp; # aby som vedel v dalsej pejdzi aky bol posledny encoding
				$H->rh("<%CODEPAGE%>",$main::LNG_cp);
				$DOC_output=$H->OUT_;
				if ($main::LNG_cp =~/^(ASCII|ISO-8859-1)$/)
				{
					$DOC_output=Int::charsets::encode::UTF8_ASCII($DOC_output);
				}
				else
				{
					use Encode;
					$DOC_output = encode_utf8($DOC_output);
					Encode::from_to($DOC_output, $TOM::LNG_cp_default, $main::LNG_cp);
				}
				$main::cache='';$main::ENV{'Cache-Control'}='no-cache';
			}
			elsif (
				($ENV{HTTP_ACCEPT_CHARSET}=~/$TOM::LNG_cp_default/i)
				||($ENV{HTTP_ACCEPT_CHARSET}=~/\*/)
				||(!$TOM::Net::HTTP::UserAgent::table[$main::UserAgent]{utf8_disable})
				) # ak podporujem utf-8
			{
				$COOKIES{_cp}=$TOM::LNG_cp_default;
				$COOKIES{cp}=$TOM::LNG_cp_default;
				$H->rh("<%CODEPAGE%>",$TOM::LNG_cp_default);
				$DOC_output=$H->OUT_;
			}
			else # tento browser nepodporuje UTF8, tak dostane ASCII 
			{
				$main::H->message("Your browser detected as \"".$main::UserAgent_name."\" does not support utf-8 encoding or does not send the information about accepted encodings through http token. The system will automatically generate this page in default (ISO-8859-1/ASCII) charset. For more information, please refer to RFC2616 chapter 3.4. and inform your software distributor, or try to upgrade your this (or to another) software.");
				main::_log("ASCII encoding for UserAgent \"$ENV{HTTP_USER_AGENT}\"-\"$TOM::Net::HTTP::UserAgent::table[$main::UserAgent]{name}\" encodings($ENV{HTTP_ACCEPT_CHARSET})");
				
				$COOKIES{cp}="ISO-8859-1";
				$H->rh("<%CODEPAGE%>","ISO-8859-1");
				$DOC_output=Int::charsets::encode::UTF8_ASCII($H->OUT_);
				$main::cache='';$main::ENV{'Cache-Control'}='no-cache';
			}
			
			#if (utf8::is_utf8($DOC_output)){main::_log("DOC_output flag is utf8");}
			
#		$t->close();};
		
		if ($result eq "failed")
		{
			# don't cache when page failed
			$main::cache='';$main::ENV{'Cache-Control'}='no-cache';
			# when page failed, send 500 error
			$main::page_statuscode="500"
				if $main::page_statuscode eq "200"; # internal server error
		}
		
		my $t_send=track TOM::Debug("send",'timer'=>1);
		
		print "C3-Request: $main::request_code\n";
		if ($tom::devel)
		{
			print "C3-Devel-Hostname: $TOM::hostname\n";
			print "C3-Devel-TID: ".$main::FORM{'TID'}."\n";
			print "C3-Devel-a210: ".$main::a210{'ID'}."\n" if $main::a210{'ID'};
			print "C3-Devel-a210_path: ".$main::FORM{'a210_path'}."\n" if $main::FORM{'a210_path'};
			print "C3-Devel-a210_name: ".$main::FORM{'a210_name'}."\n" if $main::FORM{'a210_name'};
			print "C3-Devel-branch: ".$tom::devel_branch."\n" if $tom::devel_branch;
		}
		print "C3-Domain: $tom::H\n";
			my $date = DateTime->now('time_zone' => 'local');
			my $date_string = $date->strftime("%d %b %Y %H:%M:%S");
		print "C3-Date: $date_string\n";
		print "C3-Cache-Control: ".do{
			if ($main::cache)
			{
				"cache";
			}
			elsif (not defined $main::cache)
			{
				"expunge";
			}
			else
			{
				"no-cache";
			}
		}."\n";
		print "C3-ESI: ".$main::ENV{'ESI'}."\n"
			if $main::ENV{'ESI'};
		
		foreach my $head (@main::page_header)
		{
			print $head."\n";
		}
		
#		print "Accept-CH: DPR, Width, Viewport-Width\n";
#		print "Vary: Width, Accept-Encoding\n";
#		print "Vary: Width, Accept-Encoding, Origin\n";
		print "Vary: Origin\n";
		
		if ($TOM::Document::content_security_policy)
		{
			print "Content-Security-Policy: ".($TOM::Document::content_security_policy || "frame-ancestors 'self'").";\n";
		}
		if ($TOM::Document::frame_options ne "ALLOWALL")
		{
			print "X-FRAME-OPTIONS: ".($TOM::Document::frame_options || 'SAMEORIGIN').";\n";
		}
		if ($TOM::Document::X_XSS_Protection)
		{
			print "X-XSS-Protection: ".($TOM::Document::X_XSS_Protection || '1; mode=block').";\n";
		}
		if ($TOM::Document::X_Content_Type_Options)
		{
			print "X-Content-Type-Options: ".($TOM::Document::X_Content_Type_Options || 'nosniff').";\n";
		}
		if ($tom::H_www_orig=~/^https/ && $TOM::Document::HSTS)
		{
			print "Strict-Transport-Security: max-age=15552000;\n";
		}
		
		# codepage pouzity pre tuto page;
		$main::LNG_cp_this=$COOKIES{cp};
		
		untie %{$main::USRM{'session'}} if ref($main::USRM{'session'}) eq "HASH"; # DESTROY
		
		# send cookies
		if ($main::ENV{'Cache-Control'}=~/(public|revalidate)/)
		{
			main::_log("sending cookies disabled by Cache-Control='".$main::ENV{'Cache-Control'}."'");
		}
		else
		{
			if ($main::ENV{'SERVER_NAME'}=~/$tom::D_cookie$/)
			{
				TOM::Engine::pub::cookies::send();
			}
			elsif ($main::ENV{'SERVER_NAME'})
			{
				main::_log("SERVER_NAME='$main::ENV{'SERVER_NAME'}' != tom::D_cookie='$tom::D_cookie'",1);
			}
		}
		
#		if ($TOM::DEBUG_log_file >= 99)
#		{
#			open(HND,'>'.$tom::P.'/_temp/request_response_'.$main::request_code);
#			print HND $DOC_output;
#			close(HND);
#		}
		
		
		if ($main::page_statuscode eq "400")
		{
			print "Status: 400 Bad Request\n";
		}
		elsif ($main::page_statuscode eq "401")
		{
			print "Status: 401 Unauthorized\n";
		}
		elsif ($main::page_statuscode eq "403")
		{
			print "Status: 403 Forbidden\n";
		}
		elsif ($main::page_statuscode eq "404")
		{
			print "Status: 404 Not Found\n";
		}
		elsif ($main::page_statuscode eq "500")
		{
			print "Status: 500 Internal Server Error\n";
		}
		
		if ($TOM::Document::content_type eq "application/pdf")
		{
			
			# header
			print "Connection: close\n";
			print "Content-Type: application/pdf\n";
			print "Content-Disposition: attachment; filename = ".( $main::env{'htmldoc_filename'} || TOM::Net::URI::rewrite::convert($main::H->{'env'}{'DOC_title'})).".pdf\n";
			
			# convert document
			my $charset=$main::LNG_cp;$charset=~s|^ISO-||;
			my $tmp_html=TOM::Temp::file->new('ext'=>'html');
			$tmp_html->save_content($DOC_output);
			my $tmp_pdf=TOM::Temp::file->new('ext'=>'pdf');
			my $cmd="/usr/bin/htmldoc --quiet --jpeg --charset $charset --webpage $main::env{'htmldoc'} $tmp_html->{'filename'} -f $tmp_pdf->{'filename'} 2>/www/TOM/_temp/stderr.log";
			main::_log($cmd);
			system($cmd);
			
			my $size=(stat($tmp_pdf->{'filename'}))[7];
			main::_log("DOC length = '$size'");
			print "Content-length: $size\n";
			
			# send content
			print "\n";
			binmode STDOUT;
			open (HND_PDF,'<'.$tmp_pdf->{'filename'});
			print <HND_PDF>;
			close (HND_PDF);
		}
		else
		{
			# only when page generated without errors
			if ($page_statuscode eq "200" && $main::cache)
			{
				if ($main::ENV{'Etag'}) # timestamp only pls!
				{
					$main::ENV{'Etag'}=~s|[\n\r]||gms; # fix when Base64
					print "Etag: ".$main::ENV{'Etag'}."\n";
					$main::ENV{'Last-Modified'}=time() unless $main::ENV{'Last-Modified'};
				}
				if ($main::ENV{'Last-Modified'}) # timestamp only pls!
				{
					$main::ENV{'Last-Modified'}=int($main::ENV{'Last-Modified'});
					if ($TOM::Net::HTTP::UserAgent::table[$main::UserAgent]{'agent_type'} ne "robot")
					{
						# highest value is time() for non bots
						# because cache time = last-modified time sent by webserver to browser
						# and browser after caching asks for modifications to last-modified
						$main::ENV{'Last-Modified'}=time() if $main::ENV{'Last-Modified'}<time();
					}
					use DateTime;
					# convert and publish Last-Modified header
					my $date = DateTime->from_epoch('epoch'=>int($main::ENV{'Last-Modified'}),'time_zone' => 'GMT');
					my $date_string = $date->strftime("%a, %d %b %Y %H:%M:%S GMT");
					print "Last-Modified: ".$date_string."\n";
					main::_log("[page][".$main::ENV{'Etag'}."][CRT] Last-Modified:$date_string",3,"cache");
					main::_log("[page][$tom::H][".$main::ENV{'Etag'}."][CRT] Last-Modified:$date_string",3,"cache",1);
					
					if ($Ext::Redis::service)
					{
						my $date_str=$tom::Fyear.'-'.$tom::Fmon.'-'.$tom::Fmday.' '.$tom::Fhour.':'.$tom::Fmin;
						$Ext::Redis::service->hincrby('C3|counters|page_cache|'.$date_str,'crt',1,sub{});
			#			$Ext::Redis::service->hincrby('C3|counters|page_cache|'.$date_str,'hit',1,sub{});
						$Ext::Redis::service->expire('C3|counters|page_cache|'.$date_str,3600,sub{});
					}
				}
			}
			else
			{
				# reset cache settings
				$main::ENV{'Expires'}="0";
				$main::ENV{'Cache-Control'}="no-cache";
#				$main::ENV{'Pragma'}="no-cache";
				undef $main::ENV{'Last-Modified'};
			}
			
			
			if ($main::ENV{'Expires'})
			{
				main::_log("Expires: ".$main::ENV{'Expires'});
				print "Expires: ".$main::ENV{'Expires'}."\n";
				if ($main::ENV{'Last-Modified'})
				{
					
				}
				else
				{
					
				}
			}
			if ($main::ENV{'Cache-Control'})
			{
				main::_log("Cache-Control: ".$main::ENV{'Cache-Control'});
				print "Cache-Control: ".$main::ENV{'Cache-Control'}."\n";
			}

#			if ($main::ENV{'Pragma'})
#			{
#				main::_log("Pragma: ".$main::ENV{'Pragma'});
#				print "Pragma: ".$main::ENV{'Pragma'}."\n";
#			}
			
			if ($main::H->{'env'}->{'obj'})
			{
				foreach my $obj (sort @{$main::H->{'env'}->{'obj'}})
				{
					print "C3-obj: ".$obj."\n";
				}
			}
			
			print "Content-Type: ".$TOM::Document::content_type."; charset=$main::LNG_cp_this\n";
			
			if ($TOM::Document::ACAOrigin eq "dynamic")
			{
				my $aca = $main::ENV{'HTTP_REFERER'} || $tom::H_www;
					$aca =~s|^(http[s]?://.*?)/.*$|$1|;
				$aca=$main::ENV{'HTTP_ORIGIN'} if $main::ENV{'HTTP_ORIGIN'};
				print "Access-Control-Allow-Origin: ".$aca."\n";
			}
			else
			{
				print "Access-Control-Allow-Origin: ".($TOM::Document::ACAOrigin || '*')."\n";
			}
			
			if ($ENV{'HTTP_ACCEPT_ENCODING'}=~/gzip/i && !$pub::gzip_disable)
			{
				main::_log("Gzipping DOC");
				print "Content-Encoding: gzip\n";
				# disable utf8 flag when sending data
				if (utf8::is_utf8($DOC_output))
				{
					main::_log("DOC flag is utf8");
					utf8::encode($DOC_output);
				}
				my $out=Compress::Zlib::memGzip($DOC_output);
				print "Content-length: ".(length($out))."\n";
				main::_log("DOC length = '".(length($out))."'");
				print "\n";
				binmode STDOUT;
				print $out;
			}
			else
			{
				# disable utf8 flag when sending data
				if (utf8::is_utf8($DOC_output))
				{
					main::_log("DOC flag is utf8");
					utf8::encode($DOC_output);
				}
				print "Content-length: ".(length($DOC_output))."\n";
				main::_log("DOC length = '".(length($DOC_output))."'");
				print "\n";
				print $DOC_output;
			}
		}
		
		if (($tom::HUP) && (($main::time_current-$TOM::time_start)<30))
		{
			main::_log("HUP (waiting to 30 seconds) (lives ".($main::time_current-$TOM::time_start)." secs, $tom::count requests) PID:$$ domain:$tom::H",3,"pub.mng",1);
		}
		
		$t_send->close();
		$t_postprocess->close();
		$t_eval->close();
		
#		main::_log("ID_user='".($main::USRM{'ID_user'} || $main::USRM{'IDhash'} || '        ').":".($main::USRM{'logged'} || ' ')."' IP='".($main::ENV{'REMOTE_ADDR'})."' QUERY='$main::ENV{QUERY_STRING_FULL}' REFERER='$main::ENV{HTTP_REFERER}' UserAgent='$main::UserAgent_name'/'$main::ENV{'HTTP_USER_AGENT'}'",3,'pub.track');
		
#		if ($TOM::CACHE && $TOM::CACHE_memcached){$Ext::CacheMemcache::cache->set('namespace'=>"c3process",'key' => $TOM::hostname.':'.$$,'value' => {'time' => time(),'start' => $TOM::time_start,'count' => $tom::count});}
		
		TOM::Debug::pub::request(
			'duration' => $t_eval->{'time'}{'duration'},
			'user' => $t_eval->{'time'}{'user'}{'duration'},
			'sys' => $t_eval->{'time'}{'sys'}{'duration'},
			'code' => $main::page_statuscode,
		);
		
		do
		{
			my $e_p=$t_eval->{'time'}{'proc'}{'duration'};
			my $e_r=$t_eval->{'time'}{'req'}{'duration'};
			
			if ($Ext::Redis::service)
			{
				my $date_str=$tom::Fyear.'-'.$tom::Fmon.'-'.$tom::Fmday.' '.$tom::Fhour.':'.$tom::Fmin;
#				print "date=$date_str\n";
				$Ext::Redis::service->hincrby('C3|counters|pub_bench|'.$TOM::hostname.'|'.$date_str,
					'cnt',1,sub{});
				$Ext::Redis::service->hincrby('C3|counters|pub_bench|'.$TOM::hostname.'|'.$date_str,
					'eval_req',int($e_r*1000),sub{});
				$Ext::Redis::service->hincrby('C3|counters|pub_bench|'.$TOM::hostname.'|'.$date_str,
					'eval_proc',int($e_p*1000),sub{});
#				$Ext::Redis::service->hincrby('C3|counters|pub_bench|'.$TOM::hostname.'|'.$date_str,
#					'pre_req',$t_preprocess->{'time'}{'req'}{'duration'}*1000,sub{});
#				$Ext::Redis::service->hincrby('C3|counters|pub_bench|'.$TOM::hostname.'|'.$date_str,
#					'pre_proc',$t_preprocess->{'time'}{'proc'}{'duration'}*1000,sub{});
#				$Ext::Redis::service->hincrby('C3|counters|pub_bench|'.$TOM::hostname.'|'.$date_str,
#					'pro_req',$t_process->{'time'}{'req'}{'duration'}*1000,sub{});
#				$Ext::Redis::service->hincrby('C3|counters|pub_bench|'.$TOM::hostname.'|'.$date_str,
#					'pro_proc',$t_process->{'time'}{'proc'}{'duration'}*1000,sub{});
#				$Ext::Redis::service->hincrby('C3|counters|pub_bench|'.$TOM::hostname.'|'.$date_str,
#					'post_req',$t_postprocess->{'time'}{'req'}{'duration'}*1000,sub{});
#				$Ext::Redis::service->hincrby('C3|counters|pub_bench|'.$TOM::hostname.'|'.$date_str,
#					'post_proc',$t_postprocess->{'time'}{'proc'}{'duration'}*1000,sub{});
				
#				print "r=".($e_r*1000)." p=".($e_p*1000)."\n";
				
			}
			
#			main::_log("[$tom::H]".
#				" ".
#				"TID:".$main::FORM{'TID'}.
#				" ".
#				"eval:".$e_r."/".$e_p.
#				" ".
#				"(".
#					"pre_process:".
#						$t_preprocess->{'time'}{req}{duration}.'/'.$t_preprocess->{'time'}{proc}{duration}.' '.
#						TOM::Math::percentage($e_r,$t_preprocess->{'time'}{req}{duration})."%/".
#						TOM::Math::percentage($e_p,$t_preprocess->{'time'}{proc}{duration})."%".
#					" ".
#					"process:".
#						$t_process->{'time'}{req}{duration}.'/'.$t_process->{'time'}{proc}{duration}.' '.
#						TOM::Math::percentage($e_r,$t_process->{'time'}{req}{duration})."%/".
#						TOM::Math::percentage($e_p,$t_process->{'time'}{proc}{duration})."%".
#					" ".
#					"post_process:".
#						$t_postprocess->{'time'}{req}{duration}.'/'.$t_postprocess->{'time'}{proc}{duration}.' '.
#						TOM::Math::percentage($e_r,$t_postprocess->{'time'}{req}{duration})."%/".
#						TOM::Math::percentage($e_p,$t_postprocess->{'time'}{proc}{duration})."%".
#				")".
#				"",3,"pub.bench",1) if $TOM::DEBUG_benchmark;
		};
		Coro::cede;
	}; # end of eval
	
	untie %{$main::USRM{'session'}} if ref($main::USRM{'session'}) eq "HASH"; # DESTROY
	
	if ($@)
	{
		my @ERR=("Error occured during request execution");
		push @ERR,$@;
		TOM::Error::engine(@ERR);
	}
	
	$t_request->close();
	
	# request exit/restart when important files changed
	$tom::HUP=1 if TOM::files_modified(\@main::mfiles);
	
	if (-e $TOM::P.'/_data/ip_blacklist.json' && TOM::file_modified($TOM::P.'/_data/ip_blacklist.json'))
	{
		TOM::Net::HTTP::UserAgent::initialize_hacked();
	}
	
	if (
			($tom::HUP) && (($main::time_current-$TOM::time_start)<30) || # safe time to exit/restart
			($tom::HUP == 2) ||
			($TOM::max_count && ($TOM::max_count <= $tom::count)) ||
			($TOM::max_time <= ($main::time_current-$TOM::time_start))
		)
	{
#		if ($TOM::CACHE && $TOM::CACHE_memcached){$Ext::CacheMemcache::cache->set('namespace'=>"c3process",'key' => $TOM::hostname.':'.$$,'value' => {'time' => time(),'start' => $TOM::time_start,'count' => $tom::count});}
		
		main::_log("SHUTDOWN (lives ".($main::time_current-$TOM::time_start)." secs, $tom::count requests) PID:$$ domain:$tom::H",3);
		main::_log("SHUTDOWN (lives ".($main::time_current-$TOM::time_start)." secs, $tom::count requests) PID:$$ domain:$tom::H",3,"pub.mng",1);
		Tomahawk::shutdown();
	}
	
	# check memory consumption
	if (($main::time_current-$TOM::time_start) > (60*3) && ($main::time_current-$main::time_memory_check)>=10){
	$main::time_memory_check=$main::time_current;
	eval{
		my $t = new Proc::ProcessTable;
		foreach my $p (grep {$_->{'pid'} == $$} @{$t->table})
		{
			main::_log("used memory ".Number::Bytes::Human::format_bytes($p->{'rss'}));
			if ($p->{'rss'} >= 300*1024*1024)
			{
				main::_log("SHUTDOWN (too much memory ".Number::Bytes::Human::format_bytes($p->{'rss'}).") (lives ".($main::time_current-$TOM::time_start)." secs, $tom::count requests) PID:$$ domain:$tom::H",3);
				main::_log("SHUTDOWN (too much memory ".Number::Bytes::Human::format_bytes($p->{'rss'}).") (lives ".($main::time_current-$TOM::time_start)." secs, $tom::count requests) PID:$$ domain:$tom::H",3,"pub.mng",1);
				Tomahawk::shutdown();
			}
		}
	};
	}
	
	$main::request_code="00000000";
	# re-registering ALARM
	if ($^O ne "MSWin32") # not working on Win32
	{
		POSIX::sigaction(&POSIX::SIGALRM, $TOM::Engine::pub::SIG::action_exit);
	}
	alarm($TOM::fcgi_sleep_timeout);
} # end of while
######################################################################################
######################################################################################
######################################################################################
######################################################################################
main::_log("END CGI PID:$$ domain:$tom::H",3,"pub.mng",1);


